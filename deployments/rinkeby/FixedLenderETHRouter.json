{
  "address": "0x4d34a2C841327D149b469456EC91B049404688be",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract FixedLender",
          "name": "fixedLender_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "NotFromWETH",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "maturity",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "assets",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxAssetsAllowed",
          "type": "uint256"
        }
      ],
      "name": "borrowAtMaturityETH",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "assetsOwed",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "maturity",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minAssetsRequired",
          "type": "uint256"
        }
      ],
      "name": "depositAtMaturityETH",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "maturityAssets",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "depositETH",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "shares",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fixedLender",
      "outputs": [
        {
          "internalType": "contract FixedLender",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "maturity",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "assets",
          "type": "uint256"
        }
      ],
      "name": "repayAtMaturityETH",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "repaidAssets",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "weth",
      "outputs": [
        {
          "internalType": "contract WETH",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "maturity",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "assets",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minAssetsRequired",
          "type": "uint256"
        }
      ],
      "name": "withdrawAtMaturityETH",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "actualAssets",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "assets",
          "type": "uint256"
        }
      ],
      "name": "withdrawETH",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "shares",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0xefee02702ffc758339f3ee61ae2d86334facb8079764f8596dcc4d57696977e9",
  "receipt": {
    "to": null,
    "from": "0xDb90CDB64CfF03f254e4015C4F705C3F3C834400",
    "contractAddress": "0x4d34a2C841327D149b469456EC91B049404688be",
    "transactionIndex": 7,
    "gasUsed": "688554",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000002000000000000000200000000000008000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000040000000000000000000000000000000020000000000000000000000000000000000000001000000000000000000000000000000000000000000010000000000000000000000000400000000000000000010000000000000000000000000000000000000000000000000000004000000",
    "blockHash": "0xe8cbfa419cc8a6e28c13716c2a040b97d666b1eba69b13e7f2ba79a0f177a8c6",
    "transactionHash": "0xefee02702ffc758339f3ee61ae2d86334facb8079764f8596dcc4d57696977e9",
    "logs": [
      {
        "transactionIndex": 7,
        "blockNumber": 11007888,
        "transactionHash": "0xefee02702ffc758339f3ee61ae2d86334facb8079764f8596dcc4d57696977e9",
        "address": "0xd74047010D77c5901df5b0f9ca518aED56C85e8D",
        "topics": [
          "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925",
          "0x0000000000000000000000004d34a2c841327d149b469456ec91b049404688be",
          "0x000000000000000000000000108758bf5735f6871e944be3596454edd1bb7c89"
        ],
        "data": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
        "logIndex": 16,
        "blockHash": "0xe8cbfa419cc8a6e28c13716c2a040b97d666b1eba69b13e7f2ba79a0f177a8c6"
      }
    ],
    "blockNumber": 11007888,
    "cumulativeGasUsed": "2021909",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x108758bF5735f6871e944be3596454EdD1bb7C89"
  ],
  "numDeployments": 1,
  "solcInputHash": "3885bcb2ff82e675bed0fcc39e7a5ac1",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract FixedLender\",\"name\":\"fixedLender_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotFromWETH\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAssetsAllowed\",\"type\":\"uint256\"}],\"name\":\"borrowAtMaturityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assetsOwed\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAssetsRequired\",\"type\":\"uint256\"}],\"name\":\"depositAtMaturityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maturityAssets\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixedLender\",\"outputs\":[{\"internalType\":\"contract FixedLender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"repayAtMaturityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"repaidAssets\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract WETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAssetsRequired\",\"type\":\"uint256\"}],\"name\":\"withdrawAtMaturityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"actualAssets\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/FixedLenderETHRouter.sol\":\"FixedLenderETHRouter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\",\"keccak256\":\"0xb496651006b9a2a07920ffe116928b11e2a6458e21361cecca51409522488ca7\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\",\"keccak256\":\"0x4a7757ff7bbafe044cd49c2a45c7c18ec50eff7c7af6869face5e1e9cda976f2\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0xf2b6c9adb3552254df1445b73563cf014434ff5e78663e9b961b6c059506ceb5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb4d87ee2ead4bd192b41c128f287d4b7f24b9e0cd740cc9b476881c461286007\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0x59ce320a585d7e1f163cd70390a0ef2ff9cec832e2aa544293a00692465a7a57\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0xe68ed7fb8766ed1e888291f881e36b616037f852b37d96877045319ad298ba87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x32c202bd28995dd20c4347b7c6467a6d3241c74c8ad3edcbb610cd9205916c45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\",\"keccak256\":\"0xc995bddbca1ae19788db9f8b61e63385edd3fddf89693b612d5abd1a275974d2\",\"license\":\"MIT\"},\"@rari-capital/solmate/src/mixins/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626 is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, _asset.decimals()) {\\n        asset = _asset;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf[owner]);\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n}\\n\",\"keccak256\":\"0xa0e0c28a727524fa94e7e6c1f4c793a6bd1e6d1bc652b7b02b343ebaf4cd774b\",\"license\":\"MIT\"},\"@rari-capital/solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0x43aa1509bb753f053143530705d9c4eee415691d26a4779769bf028a74e6ac69\",\"license\":\"MIT\"},\"@rari-capital/solmate/src/tokens/WETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\n\\n/// @notice Minimalist and modern Wrapped Ether implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)\\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\\ncontract WETH is ERC20(\\\"Wrapped Ether\\\", \\\"WETH\\\", 18) {\\n    using SafeTransferLib for address;\\n\\n    event Deposit(address indexed from, uint256 amount);\\n\\n    event Withdrawal(address indexed to, uint256 amount);\\n\\n    function deposit() public payable virtual {\\n        _mint(msg.sender, msg.value);\\n\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n\\n        emit Withdrawal(msg.sender, amount);\\n\\n        msg.sender.safeTransferETH(amount);\\n    }\\n\\n    receive() external payable virtual {\\n        deposit();\\n    }\\n}\\n\",\"keccak256\":\"0x9b7c1a6a154f8298c26ca09a868d5352de6006c07091dd9a90e5d4069a3a57b0\",\"license\":\"MIT\"},\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\\n    }\\n\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return 0;\\n\\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n            if (x >= 135305999368893231589) revert(\\\"EXP_OVERFLOW\\\");\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5**18;\\n\\n            // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n        }\\n    }\\n\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            require(x > 0, \\\"UNDEFINED\\\");\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            int256 k = int256(log2(uint256(x))) - 96;\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        require(x > 0, \\\"UNDEFINED\\\");\\n\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\\n            r := or(r, lt(0x1, shr(r, x)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x622fcd8a49e132df5ec7651cc6ae3aaf0cf59bdcd67a9a804a1b9e2485113b7d\",\"license\":\"MIT\"},\"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\",\"keccak256\":\"0xa0e50a0f232da7f289430601ba927c315266b20ec739761430b0fde926fefe55\",\"license\":\"MIT\"},\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(4, from) // Append the \\\"from\\\" argument.\\n            mstore(36, to) // Append the \\\"to\\\" argument.\\n            mstore(68, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because that's the total length of our calldata (4 + 32 * 3)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 100, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(4, to) // Append the \\\"to\\\" argument.\\n            mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 68, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(4, to) // Append the \\\"to\\\" argument.\\n            mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 68, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x5f2e1158c68c1f3d15b80e8a7dd92b6849f873066969562ad33c0abb80e536ff\",\"license\":\"MIT\"},\"contracts/Auditor.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { AccessControl } from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport { FixedPointMathLib } from \\\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport { FixedLender, NotFixedLender } from \\\"./FixedLender.sol\\\";\\nimport { ExactlyOracle } from \\\"./ExactlyOracle.sol\\\";\\nimport { PoolLib } from \\\"./utils/PoolLib.sol\\\";\\n\\ncontract Auditor is AccessControl {\\n  using FixedPointMathLib for uint256;\\n\\n  struct LiquidationIncentive {\\n    uint128 liquidator;\\n    uint128 lenders;\\n  }\\n\\n  // Struct to avoid stack too deep\\n  struct AccountLiquidity {\\n    uint256 balance;\\n    uint256 borrowBalance;\\n    uint256 oraclePrice;\\n  }\\n\\n  // Struct for FixedLender's markets\\n  struct Market {\\n    uint128 adjustFactor;\\n    uint8 decimals;\\n    uint8 index;\\n    bool isListed;\\n  }\\n\\n  struct MarketVars {\\n    uint256 price;\\n    uint128 adjustFactor;\\n    uint8 decimals;\\n  }\\n\\n  struct LiquidityVars {\\n    uint256 totalDebt;\\n    uint256 totalCollateral;\\n    uint256 adjustedDebt;\\n    uint256 adjustedCollateral;\\n    uint256 seizeAvailable;\\n  }\\n\\n  uint256 public constant TARGET_HEALTH = 1.25e18;\\n\\n  // Protocol Management\\n  mapping(address => uint256) public accountMarkets;\\n  mapping(FixedLender => Market) public markets;\\n\\n  LiquidationIncentive public liquidationIncentive;\\n  FixedLender[] public allMarkets;\\n\\n  ExactlyOracle public oracle;\\n\\n  /// @notice Event emitted when a new market is listed for borrow/lending.\\n  /// @param fixedLender address of the fixedLender market that was listed.\\n  event MarketListed(FixedLender fixedLender, uint8 decimals);\\n\\n  /// @notice Event emitted when a user enters a market to use his deposit as collateral for a loan.\\n  /// @param fixedLender address of the market that the user entered.\\n  /// @param account address of the user that just entered a market.\\n  event MarketEntered(FixedLender indexed fixedLender, address indexed account);\\n\\n  /// @notice Event emitted when a user leaves a market. Means that they would stop using their deposit as collateral\\n  /// and won't ask for any loans in this market.\\n  /// @param fixedLender address of the market that the user just left.\\n  /// @param account address of the user that just left a market.\\n  event MarketExited(FixedLender indexed fixedLender, address indexed account);\\n\\n  /// @notice Event emitted when a new Oracle has been set.\\n  /// @param newOracle address of the new oracle that is used to calculate liquidity.\\n  event OracleSet(ExactlyOracle newOracle);\\n\\n  /// @notice Event emitted when a new liquidationIncentive has been set.\\n  /// @param newLiquidationIncentive represented with 18 decimals.\\n  event LiquidationIncentiveSet(LiquidationIncentive newLiquidationIncentive);\\n\\n  /// @notice Event emitted when a adjust factor is changed by admin.\\n  /// @param fixedLender address of the market that has a new adjust factor.\\n  /// @param newAdjustFactor adjust factor for the underlying asset.\\n  event AdjustFactorSet(FixedLender indexed fixedLender, uint256 newAdjustFactor);\\n\\n  constructor(ExactlyOracle oracle_, LiquidationIncentive memory liquidationIncentive_) {\\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n\\n    setOracle(oracle_);\\n    setLiquidationIncentive(liquidationIncentive_);\\n  }\\n\\n  /// @notice Allows assets of a certain `fixedLender` market to be used as collateral for borrowing other assets.\\n  /// @param fixedLender market to enable as collateral for `msg.sender`.\\n  function enterMarket(FixedLender fixedLender) external {\\n    validateMarketListed(fixedLender);\\n    uint256 marketIndex = markets[fixedLender].index;\\n\\n    uint256 marketMap = accountMarkets[msg.sender];\\n\\n    if ((marketMap & (1 << marketIndex)) != 0) return;\\n    accountMarkets[msg.sender] = marketMap | (1 << marketIndex);\\n\\n    emit MarketEntered(fixedLender, msg.sender);\\n  }\\n\\n  /// @notice Removes fixedLender from sender's account liquidity calculation.\\n  /// @dev Sender must not have an outstanding borrow balance in the asset, or be providing necessary collateral\\n  /// for an outstanding borrow.\\n  /// @param fixedLender The address of the asset to be removed.\\n  function exitMarket(FixedLender fixedLender) external {\\n    validateMarketListed(fixedLender);\\n    uint256 marketIndex = markets[fixedLender].index;\\n\\n    (uint256 assets, uint256 debt) = fixedLender.getAccountSnapshot(msg.sender);\\n\\n    // Fail if the sender has a borrow balance\\n    if (debt != 0) revert BalanceOwed();\\n\\n    // Fail if the sender is not permitted to redeem all of their tokens\\n    validateAccountShortfall(fixedLender, msg.sender, assets);\\n\\n    uint256 marketMap = accountMarkets[msg.sender];\\n\\n    if ((marketMap & (1 << marketIndex)) == 0) return;\\n    accountMarkets[msg.sender] = marketMap & ~(1 << marketIndex);\\n\\n    emit MarketExited(fixedLender, msg.sender);\\n  }\\n\\n  /// @notice Sets Oracle's to be used.\\n  /// @param _priceOracle address of the new oracle.\\n  function setOracle(ExactlyOracle _priceOracle) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    oracle = _priceOracle;\\n    emit OracleSet(_priceOracle);\\n  }\\n\\n  /// @notice Sets liquidation incentive for the whole ecosystem.\\n  /// @dev Value can only be set between 20% and 5%.\\n  /// @param liquidationIncentive_ new liquidation incentive.\\n  function setLiquidationIncentive(LiquidationIncentive memory liquidationIncentive_)\\n    public\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n  {\\n    if (\\n      liquidationIncentive_.liquidator > 0.2e18 ||\\n      liquidationIncentive_.liquidator < 0.05e18 ||\\n      liquidationIncentive_.lenders > 0.1e18\\n    ) {\\n      revert InvalidParameter();\\n    }\\n    liquidationIncentive = liquidationIncentive_;\\n    emit LiquidationIncentiveSet(liquidationIncentive_);\\n  }\\n\\n  /// @notice Enables a certain FixedLender market.\\n  /// @dev Enabling more than 256 markets will cause an overflow when casting market index to uint8.\\n  /// @param fixedLender address to add to the protocol.\\n  /// @param adjustFactor fixedLender's adjust factor for the underlying asset.\\n  /// @param decimals decimals of the market's underlying asset.\\n  function enableMarket(\\n    FixedLender fixedLender,\\n    uint128 adjustFactor,\\n    uint8 decimals\\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n    if (fixedLender.auditor() != this) revert AuditorMismatch();\\n\\n    if (markets[fixedLender].isListed) revert MarketAlreadyListed();\\n\\n    markets[fixedLender] = Market({\\n      isListed: true,\\n      adjustFactor: adjustFactor,\\n      decimals: decimals,\\n      index: uint8(allMarkets.length)\\n    });\\n\\n    allMarkets.push(fixedLender);\\n\\n    emit MarketListed(fixedLender, decimals);\\n    setAdjustFactor(fixedLender, adjustFactor);\\n  }\\n\\n  /// @notice Sets the adjust factor for a certain fixedLender.\\n  /// @dev Market should be listed and value can only be set between 90% and 30%.\\n  /// @param fixedLender address of the market to change adjust factor for.\\n  /// @param adjustFactor adjust factor for the underlying asset.\\n  function setAdjustFactor(FixedLender fixedLender, uint128 adjustFactor) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    validateMarketListed(fixedLender);\\n    if (adjustFactor > 0.9e18 || adjustFactor < 0.3e18) revert InvalidParameter();\\n    markets[fixedLender].adjustFactor = adjustFactor;\\n    emit AdjustFactorSet(fixedLender, adjustFactor);\\n  }\\n\\n  /// @notice Validates that the current state of the position and system are valid (liquidity).\\n  /// @dev Hook function to be called after adding the borrowed debt to the user position.\\n  /// @param fixedLender address of the fixedLender where the borrow is made.\\n  /// @param borrower address of the account that will repay the debt.\\n  function validateBorrow(FixedLender fixedLender, address borrower) external {\\n    validateMarketListed(fixedLender);\\n    uint256 marketIndex = markets[fixedLender].index;\\n    uint256 marketMap = accountMarkets[borrower];\\n\\n    // we validate borrow state\\n    if ((marketMap & (1 << marketIndex)) == 0) {\\n      // only fixedLenders may call validateBorrow if borrower not in market\\n      if (msg.sender != address(fixedLender)) revert NotFixedLender();\\n\\n      accountMarkets[borrower] = marketMap | (1 << marketIndex);\\n      emit MarketEntered(fixedLender, borrower);\\n\\n      // it should be impossible to break this invariant\\n      assert((accountMarkets[borrower] & (1 << marketIndex)) != 0);\\n    }\\n\\n    // We verify that current liquidity is not short\\n    (uint256 collateral, uint256 debt) = accountLiquidity(borrower, fixedLender, 0);\\n    if (collateral < debt) revert InsufficientLiquidity();\\n  }\\n\\n  /// @notice Allows/rejects liquidation of assets.\\n  /// @dev This function can be called externally, but only will have effect when called from a fixedLender.\\n  /// @param repayMarket market from where the debt is pending.\\n  /// @param seizeMarket market where the assets will be liquidated (should be msg.sender on FixedLender.sol).\\n  /// @param borrower address which the assets are being liquidated.\\n  /// @param maxLiquidatorAssets maximum amount the liquidator can pay.\\n  function checkLiquidation(\\n    FixedLender repayMarket,\\n    FixedLender seizeMarket,\\n    address borrower,\\n    uint256 maxLiquidatorAssets\\n  ) external view returns (uint256 maxRepayAssets, bool moreCollateral) {\\n    // if markets are listed, they have the same auditor\\n    if (!markets[repayMarket].isListed || !markets[seizeMarket].isListed) revert MarketNotListed();\\n\\n    MarketVars memory repay;\\n    LiquidityVars memory usd;\\n    uint256 marketMap = accountMarkets[borrower];\\n    uint256 marketCount = allMarkets.length;\\n    for (uint256 i = 0; i < marketCount; ) {\\n      if ((marketMap & (1 << i)) != 0) {\\n        FixedLender market = allMarkets[i];\\n        Market memory memMarket = markets[market];\\n        MarketVars memory m = MarketVars({\\n          price: oracle.getAssetPrice(market),\\n          adjustFactor: memMarket.adjustFactor,\\n          decimals: memMarket.decimals\\n        });\\n\\n        if (market == repayMarket) repay = m;\\n\\n        (uint256 collateral, uint256 debt) = market.getAccountSnapshot(borrower);\\n\\n        uint256 value = debt.mulDivUp(m.price, 10**m.decimals);\\n        usd.totalDebt += value;\\n        usd.adjustedDebt += value.divWadUp(m.adjustFactor);\\n\\n        value = collateral.mulDivDown(m.price, 10**m.decimals);\\n        usd.totalCollateral += value;\\n        usd.adjustedCollateral += value.mulWadDown(m.adjustFactor);\\n        if (market == seizeMarket) usd.seizeAvailable = value;\\n      }\\n      unchecked {\\n        ++i;\\n      }\\n      if ((1 << i) > marketMap) break;\\n    }\\n\\n    if (usd.adjustedCollateral >= usd.adjustedDebt) revert InsufficientShortfall();\\n\\n    LiquidationIncentive memory memIncentive = liquidationIncentive;\\n    uint256 adjustFactor = usd.adjustedCollateral.mulDivUp(\\n      usd.totalDebt,\\n      usd.totalCollateral.mulWadDown(usd.adjustedDebt)\\n    );\\n    uint256 closeFactor = (TARGET_HEALTH - usd.adjustedCollateral.divWadUp(usd.adjustedDebt)).divWadUp(\\n      TARGET_HEALTH - adjustFactor.mulWadDown(1e18 + memIncentive.liquidator + memIncentive.lenders)\\n    );\\n    maxRepayAssets = Math.min(\\n      Math\\n        .min(\\n          usd.totalDebt.mulWadUp(Math.min(1e18, closeFactor)),\\n          usd.seizeAvailable.divWadUp(1e18 + memIncentive.liquidator + memIncentive.lenders)\\n        )\\n        .mulDivUp(10**repay.decimals, repay.price),\\n      maxLiquidatorAssets < type(uint256).max\\n        ? maxLiquidatorAssets.divWadDown(1e18 + memIncentive.lenders)\\n        : type(uint256).max\\n    );\\n    moreCollateral = usd.totalCollateral > usd.seizeAvailable;\\n  }\\n\\n  /// @notice Allow/rejects seizing of assets.\\n  /// @dev This function can be called externally, but only will have effect when called from a fixedLender.\\n  /// @param seizeMarket market where the assets will be seized (should be msg.sender on FixedLender.sol).\\n  /// @param repayMarket market from where the debt will be paid.\\n  function checkSeize(FixedLender seizeMarket, FixedLender repayMarket) external view {\\n    // If markets are listed, they have also the same Auditor\\n    if (!markets[seizeMarket].isListed || !markets[repayMarket].isListed) revert MarketNotListed();\\n  }\\n\\n  /// @notice Calculates the amount of collateral to be seized when a position is undercollateralized.\\n  /// @param repayMarket market from where the debt is pending.\\n  /// @param seizeMarket market where the assets will be liquidated (should be msg.sender on FixedLender.sol).\\n  /// @param actualRepayAssets repay amount in the borrowed asset.\\n  function liquidateCalculateSeizeAmount(\\n    FixedLender repayMarket,\\n    FixedLender seizeMarket,\\n    address borrower,\\n    uint256 actualRepayAssets\\n  ) external view returns (uint256 seizeAssets, uint256 lendersAssets) {\\n    // Read oracle prices for borrowed and collateral markets\\n    uint256 priceBorrowed = oracle.getAssetPrice(repayMarket);\\n    uint256 priceCollateral = oracle.getAssetPrice(seizeMarket);\\n\\n    uint256 amountInUSD = actualRepayAssets.mulDivUp(priceBorrowed, 10**markets[repayMarket].decimals);\\n    // 10**18: usd amount decimals\\n    seizeAssets = Math.min(\\n      amountInUSD.mulDivUp(10**markets[seizeMarket].decimals, priceCollateral).mulWadUp(\\n        1e18 + liquidationIncentive.liquidator + liquidationIncentive.lenders\\n      ),\\n      seizeMarket.maxWithdraw(borrower)\\n    );\\n    lendersAssets = actualRepayAssets.mulWadDown(liquidationIncentive.lenders);\\n  }\\n\\n  /// @notice Retrieves all markets.\\n  function getAllMarkets() external view returns (FixedLender[] memory) {\\n    return allMarkets;\\n  }\\n\\n  /// @notice Checks if the user has an account liquidity shortfall\\n  /// @dev This function is called indirectly from fixedLender contracts(withdraw), eToken transfers and directly from\\n  /// this contract when the user wants to exit a market.\\n  /// @param fixedLender address of the fixedLender where the smart pool belongs.\\n  /// @param account address of the user to check for possible shortfall.\\n  /// @param amount amount that the user wants to withdraw or transfer.\\n  function validateAccountShortfall(\\n    FixedLender fixedLender,\\n    address account,\\n    uint256 amount\\n  ) public view {\\n    // If the user is not 'in' the market, then we can bypass the liquidity check\\n    if ((accountMarkets[account] & (1 << markets[fixedLender].index)) == 0) return;\\n\\n    // Otherwise, perform a hypothetical liquidity check to guard against shortfall\\n    (uint256 collateral, uint256 debt) = accountLiquidity(account, fixedLender, amount);\\n    if (collateral < debt) revert InsufficientLiquidity();\\n  }\\n\\n  /// @notice Returns account's liquidity for a certain market.\\n  /// @param account wallet which the liquidity will be calculated.\\n  /// @param fixedLenderToSimulate fixedLender in which we want to simulate withdraw/borrow ops (see next two args).\\n  /// @param withdrawAmount amount to simulate withdraw.\\n  /// @return sumCollateral sum of all collateral, already multiplied by each adjust factor. denominated in usd.\\n  /// @return sumDebtPlusEffects sum of all debt. denominated in usd.\\n  function accountLiquidity(\\n    address account,\\n    FixedLender fixedLenderToSimulate,\\n    uint256 withdrawAmount\\n  ) public view returns (uint256 sumCollateral, uint256 sumDebtPlusEffects) {\\n    AccountLiquidity memory vars; // Holds all our calculation results\\n\\n    // For each asset the account is in\\n    uint256 marketMap = accountMarkets[account];\\n    uint256 maxValue = allMarkets.length;\\n    for (uint256 i = 0; i < maxValue; ) {\\n      if ((marketMap & (1 << i)) != 0) {\\n        FixedLender market = allMarkets[i];\\n        uint256 decimals = markets[market].decimals;\\n        uint256 adjustFactor = markets[market].adjustFactor;\\n\\n        // Read the balances\\n        (vars.balance, vars.borrowBalance) = market.getAccountSnapshot(account);\\n\\n        // Get the normalized price of the asset (18 decimals)\\n        vars.oraclePrice = oracle.getAssetPrice(market);\\n\\n        // We sum all the collateral prices\\n        sumCollateral += vars.balance.mulDivDown(vars.oraclePrice, 10**decimals).mulWadDown(adjustFactor);\\n\\n        // We sum all the debt\\n        sumDebtPlusEffects += vars.borrowBalance.mulDivUp(vars.oraclePrice, 10**decimals).divWadUp(adjustFactor);\\n\\n        // Simulate the effects of withdrawing from a pool\\n        if (market == fixedLenderToSimulate) {\\n          // Calculate the effects of redeeming fixedLenders\\n          // (having less collateral is the same as having more debt for this calculation)\\n          if (withdrawAmount != 0) {\\n            sumDebtPlusEffects += withdrawAmount.mulDivDown(vars.oraclePrice, 10**decimals).mulWadDown(adjustFactor);\\n          }\\n        }\\n      }\\n      unchecked {\\n        ++i;\\n      }\\n      if ((1 << i) > marketMap) break;\\n    }\\n  }\\n\\n  /// @notice Verifies if market is listed as valid.\\n  /// @param fixedLender address of the fixedLender to be validated by the auditor.\\n  function validateMarketListed(FixedLender fixedLender) internal view {\\n    if (!markets[fixedLender].isListed) revert MarketNotListed();\\n  }\\n}\\n\\nerror AuditorMismatch();\\nerror BalanceOwed();\\nerror InsufficientLiquidity();\\nerror InsufficientShortfall();\\nerror InvalidParameter();\\nerror MarketAlreadyListed();\\nerror MarketNotListed();\\n\",\"keccak256\":\"0x778df01c0d560e1b0a52f5515d1ef0de1d77153835d39c08ad83e2b21978f23e\",\"license\":\"GPL-3.0-or-later\"},\"contracts/ExactlyOracle.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\nimport { AccessControl } from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport { AggregatorV2V3Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\nimport { FixedLender } from \\\"./FixedLender.sol\\\";\\n\\n/// @title ExactlyOracle\\n/// @notice Proxy to get the price of an asset from a price source (Chainlink Price Feed Aggregator).\\ncontract ExactlyOracle is AccessControl {\\n  /// @notice Auditor's target precision.\\n  uint256 public constant TARGET_DECIMALS = 18;\\n  /// @notice Chainlink's Price Feed precision when using USD as the base currency.\\n  uint256 public constant ORACLE_DECIMALS = 8;\\n\\n  mapping(FixedLender => AggregatorV2V3Interface) public assetsSources;\\n  uint256 public immutable priceExpiration;\\n\\n  /// @notice Emitted when a FixedLender and source is changed by admin.\\n  /// @param fixedLender address of the asset used to get the price from this oracle.\\n  /// @param source address of Chainlink's Price Feed aggregator used to query the asset price in USD.\\n  event AssetSourceSet(FixedLender indexed fixedLender, AggregatorV2V3Interface indexed source);\\n\\n  /// @notice Constructor.\\n  /// @param priceExpiration_ The max delay time for Chainlink's prices to be considered as updated.\\n  constructor(uint256 priceExpiration_) {\\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n\\n    priceExpiration = priceExpiration_;\\n  }\\n\\n  /// @notice Sets the Chainlink Price Feed Aggregator source for an asset.\\n  /// @param fixedLender The FixedLender address of the asset.\\n  /// @param source address of Chainlink's Price Feed aggregator used to query the asset price in USD.\\n  function setAssetSource(FixedLender fixedLender, AggregatorV2V3Interface source)\\n    external\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n  {\\n    if (source.decimals() != ORACLE_DECIMALS) revert InvalidSource();\\n    assetsSources[fixedLender] = source;\\n    emit AssetSourceSet(fixedLender, source);\\n  }\\n\\n  /// @notice Gets an asset price by FixedLender.\\n  /// @dev If Chainlink's asset price is <= 0 or the updatedAt time is outdated the call is reverted.\\n  /// @param fixedLender The FixedLender address of the asset.\\n  /// @return The price of the asset scaled to 18-digit decimals.\\n  function getAssetPrice(FixedLender fixedLender) public view returns (uint256) {\\n    (, int256 price, , uint256 updatedAt, ) = assetsSources[fixedLender].latestRoundData();\\n    if (price > 0 && block.timestamp - updatedAt <= priceExpiration) return scaleOraclePriceByDigits(uint256(price));\\n    else revert InvalidPrice();\\n  }\\n\\n  /// @notice Scale the price returned by the oracle to an 18-digit decimal to be used by the Auditor.\\n  /// @param price The price to be scaled.\\n  /// @return The price of the asset scaled to 18-digit decimals.\\n  function scaleOraclePriceByDigits(uint256 price) internal pure returns (uint256) {\\n    return price * 10**(TARGET_DECIMALS - ORACLE_DECIMALS);\\n  }\\n}\\n\\nerror InvalidPrice();\\nerror InvalidSource();\\n\",\"keccak256\":\"0x934553625560d378075ff36b713e755922e9edc3f8a1c6940a274509bad4de62\",\"license\":\"GPL-3.0-or-later\"},\"contracts/FixedLender.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { Pausable } from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport { AccessControl } from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport { ReentrancyGuard } from \\\"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\\\";\\nimport { FixedPointMathLib } from \\\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport { ERC4626, ERC20, SafeTransferLib } from \\\"@rari-capital/solmate/src/mixins/ERC4626.sol\\\";\\nimport { PoolLib, InsufficientProtocolLiquidity } from \\\"./utils/PoolLib.sol\\\";\\nimport { Auditor, InvalidParameter } from \\\"./Auditor.sol\\\";\\nimport { InterestRateModel } from \\\"./InterestRateModel.sol\\\";\\nimport { TSUtils } from \\\"./utils/TSUtils.sol\\\";\\n\\ncontract FixedLender is ERC4626, AccessControl, ReentrancyGuard, Pausable {\\n  using FixedPointMathLib for int256;\\n  using FixedPointMathLib for uint256;\\n  using FixedPointMathLib for uint128;\\n  using SafeTransferLib for ERC20;\\n  using PoolLib for PoolLib.FixedPool;\\n  using PoolLib for PoolLib.Position;\\n  using PoolLib for uint256;\\n\\n  bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n  uint256 public constant CLOSE_FACTOR = 5e17;\\n\\n  struct DampSpeed {\\n    uint256 up;\\n    uint256 down;\\n  }\\n\\n  mapping(uint256 => mapping(address => PoolLib.Position)) public fixedDepositPositions;\\n  mapping(uint256 => mapping(address => PoolLib.Position)) public fixedBorrowPositions;\\n\\n  mapping(address => uint256) public fixedBorrows;\\n  mapping(address => uint256) public fixedDeposits;\\n  mapping(uint256 => PoolLib.FixedPool) public fixedPools;\\n  uint256 public smartPoolBorrowed;\\n  uint256 public smartPoolEarningsAccumulator;\\n  uint256 public penaltyRate;\\n  uint256 public dampSpeedUp;\\n  uint256 public dampSpeedDown;\\n\\n  uint8 public maxFuturePools;\\n  uint32 public lastAccumulatedEarningsAccrual;\\n  uint32 public lastAverageUpdate;\\n\\n  InterestRateModel public interestRateModel;\\n  Auditor public immutable auditor;\\n\\n  uint128 public accumulatedEarningsSmoothFactor;\\n  uint128 public smartPoolReserveFactor;\\n\\n  uint256 public smartPoolAssets;\\n  uint256 public smartPoolAssetsAverage;\\n\\n  /// @notice Event emitted when a user deposits an amount of an asset to a certain fixed rate pool collecting a fee at\\n  /// the end of the period.\\n  /// @param maturity maturity at which the user will be able to collect his deposit + his fee.\\n  /// @param caller address which deposited the assets.\\n  /// @param owner address that will be able to withdraw the deposited assets.\\n  /// @param assets amount of the asset that were deposited.\\n  /// @param fee is the extra amount that it will be collected at maturity.\\n  event DepositAtMaturity(\\n    uint256 indexed maturity,\\n    address indexed caller,\\n    address indexed owner,\\n    uint256 assets,\\n    uint256 fee\\n  );\\n\\n  /// @notice Event emitted when a user withdraws from a fixed rate pool.\\n  /// @param maturity maturity where the user withdraw its deposits.\\n  /// @param caller address which withdraw the asset.\\n  /// @param receiver address which will be collecting the assets.\\n  /// @param owner address which had the assets withdrawn.\\n  /// @param assets amount of the asset that were withdrawn.\\n  /// @param assetsDiscounted amount of the asset that were deposited (in case of early withdrawal).\\n  event WithdrawAtMaturity(\\n    uint256 indexed maturity,\\n    address caller,\\n    address indexed receiver,\\n    address indexed owner,\\n    uint256 assets,\\n    uint256 assetsDiscounted\\n  );\\n\\n  /// @notice Event emitted when a user borrows amount of an asset from a certain maturity date.\\n  /// @param maturity maturity in which the user will have to repay the loan.\\n  /// @param caller address which borrowed the asset.\\n  /// @param receiver address that received the borrowed assets.\\n  /// @param borrower address which will be repaying the borrowed assets.\\n  /// @param assets amount of the asset that were borrowed.\\n  /// @param fee extra amount that will need to be paid at maturity.\\n  event BorrowAtMaturity(\\n    uint256 indexed maturity,\\n    address caller,\\n    address indexed receiver,\\n    address indexed borrower,\\n    uint256 assets,\\n    uint256 fee\\n  );\\n\\n  /// @notice Event emitted when a user repays its borrows after maturity.\\n  /// @param maturity maturity where the user repaid its borrowed amounts.\\n  /// @param caller address which repaid the previously borrowed amount.\\n  /// @param borrower address which had the original debt.\\n  /// @param assets amount that was repaid.\\n  /// @param positionAssets amount of the debt that was covered in this repayment (penalties could have been repaid).\\n  event RepayAtMaturity(\\n    uint256 indexed maturity,\\n    address indexed caller,\\n    address indexed borrower,\\n    uint256 assets,\\n    uint256 positionAssets\\n  );\\n\\n  /// @notice Event emitted when a user's position had a liquidation.\\n  /// @param receiver address which repaid the previously borrowed amount.\\n  /// @param borrower address which had the original debt.\\n  /// @param assets amount of the asset that were repaid.\\n  /// @param lendersAssets incentive paid to lenders.\\n  /// @param collateralMarket address of the asset that were seized by the liquidator.\\n  /// @param seizedAssets amount seized of the collateral.\\n  event LiquidateBorrow(\\n    address indexed receiver,\\n    address indexed borrower,\\n    uint256 assets,\\n    uint256 lendersAssets,\\n    FixedLender indexed collateralMarket,\\n    uint256 seizedAssets\\n  );\\n\\n  /// @notice Event emitted when a user's collateral has been seized.\\n  /// @param liquidator address which seized this collateral.\\n  /// @param borrower address which had the original debt.\\n  /// @param assets amount seized of the collateral.\\n  event AssetSeized(address indexed liquidator, address indexed borrower, uint256 assets);\\n\\n  /// @notice Event emitted when earnings are accrued to the smart pool.\\n  /// @param previousAssets previous balance of the smart pool, denominated in assets (underlying).\\n  /// @param earnings new smart pool earnings, denominated in assets (underlying).\\n  event SmartPoolEarningsAccrued(uint256 previousAssets, uint256 earnings);\\n\\n  /// @notice Event emitted when the accumulatedEarningsSmoothFactor is changed by admin.\\n  /// @param newAccumulatedEarningsSmoothFactor factor represented with 1e18 decimals.\\n  event AccumulatedEarningsSmoothFactorSet(uint128 newAccumulatedEarningsSmoothFactor);\\n\\n  /// @notice Event emitted when the maxFuturePools is changed by admin.\\n  /// @param newMaxFuturePools represented with 0 decimals.\\n  event MaxFuturePoolsSet(uint256 newMaxFuturePools);\\n\\n  /// @notice emitted when the interestRateModel is changed by admin.\\n  /// @param newInterestRateModel new interest rate model to be used to calculate rates.\\n  event InterestRateModelSet(InterestRateModel indexed newInterestRateModel);\\n\\n  /// @notice emitted when the penaltyRate is changed by admin.\\n  /// @param newPenaltyRate penaltyRate percentage per second represented with 1e18 decimals.\\n  event PenaltyRateSet(uint256 newPenaltyRate);\\n\\n  /// @notice emitted when the smartPoolReserveFactor is changed by admin.\\n  /// @param newSmartPoolReserveFactor smartPoolReserveFactor percentage.\\n  event SmartPoolReserveFactorSet(uint128 newSmartPoolReserveFactor);\\n\\n  /// @notice emitted when the damp speeds are changed by admin.\\n  /// @param newDampSpeedUp represented with 1e18 decimals.\\n  /// @param newDampSpeedDown represented with 1e18 decimals.\\n  event DampSpeedSet(uint256 newDampSpeedUp, uint256 newDampSpeedDown);\\n\\n  event MarketUpdated(\\n    uint256 timestamp,\\n    uint256 smartPoolShares,\\n    uint256 smartPoolAssets,\\n    uint256 smartPoolEarningsAccumulator,\\n    uint256 indexed maturity,\\n    uint256 maturityUnassignedEarnings\\n  );\\n\\n  constructor(\\n    ERC20 asset_,\\n    uint8 maxFuturePools_,\\n    uint128 accumulatedEarningsSmoothFactor_,\\n    Auditor auditor_,\\n    InterestRateModel interestRateModel_,\\n    uint256 penaltyRate_,\\n    uint128 smartPoolReserveFactor_,\\n    DampSpeed memory dampSpeed_\\n  )\\n    ERC4626(asset_, string(abi.encodePacked(\\\"EToken\\\", asset_.symbol())), string(abi.encodePacked(\\\"e\\\", asset_.symbol())))\\n  {\\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n\\n    auditor = auditor_;\\n    setMaxFuturePools(maxFuturePools_);\\n    setAccumulatedEarningsSmoothFactor(accumulatedEarningsSmoothFactor_);\\n    setInterestRateModel(interestRateModel_);\\n    setPenaltyRate(penaltyRate_);\\n    setSmartPoolReserveFactor(smartPoolReserveFactor_);\\n    setDampSpeed(dampSpeed_);\\n  }\\n\\n  /// @notice Calculates the smart pool balance plus earnings to be accrued at current timestamp\\n  /// from maturities and accumulator.\\n  /// @return actual smartPoolAssets plus earnings to be accrued at current timestamp.\\n  function totalAssets() public view override returns (uint256) {\\n    unchecked {\\n      uint256 memMaxFuturePools = maxFuturePools;\\n      uint256 smartPoolEarnings = 0;\\n\\n      uint256 lastAccrual;\\n      uint256 unassignedEarnings;\\n      uint256 latestMaturity = block.timestamp - (block.timestamp % TSUtils.INTERVAL);\\n      uint256 maxMaturity = latestMaturity + memMaxFuturePools * TSUtils.INTERVAL;\\n\\n      assembly {\\n        mstore(0x20, fixedPools.slot) // hashing scratch space, second word for storage location hashing\\n      }\\n\\n      for (uint256 maturity = latestMaturity; maturity <= maxMaturity; maturity += TSUtils.INTERVAL) {\\n        assembly {\\n          mstore(0x00, maturity) // hashing scratch space, first word for storage location hashing\\n          let location := keccak256(0x00, 0x40) // struct storage location: keccak256([maturity, fixedPools.slot])\\n          unassignedEarnings := sload(add(location, 2)) // third word\\n          lastAccrual := sload(add(location, 3)) // forth word\\n        }\\n\\n        if (maturity > lastAccrual) {\\n          smartPoolEarnings += unassignedEarnings.mulDivDown(block.timestamp - lastAccrual, maturity - lastAccrual);\\n        }\\n      }\\n\\n      return smartPoolAssets + smartPoolEarnings + smartPoolAccumulatedEarnings();\\n    }\\n  }\\n\\n  /// @notice Withdraws the owner's smart pool assets to the receiver address.\\n  /// @dev Makes sure that the owner doesn't have shortfall after withdrawing.\\n  /// @param assets amount of underlying to be withdrawn.\\n  /// @param receiver address to which the assets will be transferred.\\n  /// @param owner address which owns the smart pool assets.\\n  function withdraw(\\n    uint256 assets,\\n    address receiver,\\n    address owner\\n  ) public override returns (uint256 shares) {\\n    auditor.validateAccountShortfall(this, owner, assets);\\n    shares = super.withdraw(assets, receiver, owner);\\n    emit MarketUpdated(block.timestamp, totalSupply, smartPoolAssets, smartPoolEarningsAccumulator, 0, 0);\\n  }\\n\\n  /// @notice Redeems the owner's smart pool assets to the receiver address.\\n  /// @dev Makes sure that the owner doesn't have shortfall after withdrawing.\\n  /// @param shares amount of shares to be redeemed for underlying asset.\\n  /// @param receiver address to which the assets will be transferred.\\n  /// @param owner address which owns the smart pool assets.\\n  function redeem(\\n    uint256 shares,\\n    address receiver,\\n    address owner\\n  ) public override returns (uint256 assets) {\\n    auditor.validateAccountShortfall(this, owner, previewMint(shares));\\n    assets = super.redeem(shares, receiver, owner);\\n    emit MarketUpdated(block.timestamp, totalSupply, smartPoolAssets, smartPoolEarningsAccumulator, 0, 0);\\n  }\\n\\n  /// @notice Hook to update the smart pool average, smart pool balance and distribute earnings from accumulator.\\n  /// @param assets amount of assets to be withdrawn from the smart pool.\\n  function beforeWithdraw(uint256 assets, uint256) internal override {\\n    updateSmartPoolAssetsAverage();\\n    uint256 earnings = smartPoolAccumulatedEarnings();\\n    lastAccumulatedEarningsAccrual = uint32(block.timestamp);\\n    smartPoolEarningsAccumulator -= earnings;\\n    uint256 memSPAssets = smartPoolAssets;\\n    emit SmartPoolEarningsAccrued(memSPAssets, earnings);\\n    memSPAssets = memSPAssets + earnings - assets;\\n    smartPoolAssets = memSPAssets;\\n    // we check if the underlying liquidity that the user wants to withdraw is borrowed\\n    if (memSPAssets < smartPoolBorrowed) revert InsufficientProtocolLiquidity();\\n  }\\n\\n  /// @notice Hook to update the smart pool average, smart pool balance and distribute earnings from accumulator.\\n  /// @param assets amount of assets to be deposited to the smart pool.\\n  function afterDeposit(uint256 assets, uint256) internal virtual override whenNotPaused {\\n    uint256 memSPAssets = smartPoolAssets;\\n    updateSmartPoolAssetsAverage();\\n    uint256 earnings = smartPoolAccumulatedEarnings();\\n    lastAccumulatedEarningsAccrual = uint32(block.timestamp);\\n    smartPoolEarningsAccumulator -= earnings;\\n    emit SmartPoolEarningsAccrued(memSPAssets, earnings);\\n    smartPoolAssets = memSPAssets + earnings + assets;\\n    emit MarketUpdated(block.timestamp, totalSupply, smartPoolAssets, smartPoolEarningsAccumulator, 0, 0);\\n  }\\n\\n  /// @notice Calculates the earnings to be distributed from the accumulator given the current timestamp.\\n  /// @return earnings to be distributed from the accumulator.\\n  function smartPoolAccumulatedEarnings() internal view returns (uint256 earnings) {\\n    uint256 elapsed = block.timestamp - lastAccumulatedEarningsAccrual;\\n    if (elapsed == 0) return 0;\\n    earnings = smartPoolEarningsAccumulator.mulDivDown(\\n      elapsed,\\n      elapsed + accumulatedEarningsSmoothFactor.mulWadDown(maxFuturePools * TSUtils.INTERVAL)\\n    );\\n  }\\n\\n  /// @notice Moves amount of shares from the caller's account to `to`.\\n  /// @dev It's expected that this function can't be paused to prevent freezing user funds.\\n  /// Makes sure that the caller doesn't have shortfall after transferring.\\n  /// @param to address to which the tokens will be transferred.\\n  /// @param shares amount of tokens.\\n  function transfer(address to, uint256 shares) public virtual override returns (bool) {\\n    auditor.validateAccountShortfall(this, msg.sender, previewMint(shares));\\n    return super.transfer(to, shares);\\n  }\\n\\n  /// @notice Moves amount of shares from `from` to `to` using the allowance mechanism.\\n  /// @dev It's expected that this function can't be paused to prevent freezing user funds.\\n  /// Makes sure that `from` address doesn't have shortfall after transferring.\\n  /// @param from address from which the tokens will be transferred.\\n  /// @param to address to which the tokens will be transferred.\\n  /// @param shares amount of tokens.\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 shares\\n  ) public virtual override returns (bool) {\\n    auditor.validateAccountShortfall(this, from, previewMint(shares));\\n    return super.transferFrom(from, to, shares);\\n  }\\n\\n  /// @notice Sets the protocol's max future pools for borrowing and lending.\\n  /// @dev Value can not be 0 or higher than 224.\\n  /// Value shouldn't be lower than previous value or VALID maturities will become NOT_READY.\\n  /// @param futurePools number of pools to be active at the same time.\\n  function setMaxFuturePools(uint8 futurePools) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    if (futurePools > 224 || futurePools == 0) revert InvalidParameter();\\n    maxFuturePools = futurePools;\\n    emit MaxFuturePoolsSet(futurePools);\\n  }\\n\\n  /// @notice Sets the factor used when smoothly accruing earnings to the smart pool.\\n  /// @dev Value can only be lower than 4. If set at 0, then all remaining accumulated earnings are\\n  /// distributed in following operation to the smart pool.\\n  /// @param accumulatedEarningsSmoothFactor_ represented with 18 decimals.\\n  function setAccumulatedEarningsSmoothFactor(uint128 accumulatedEarningsSmoothFactor_)\\n    public\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n  {\\n    if (accumulatedEarningsSmoothFactor_ > 4e18) revert InvalidParameter();\\n    accumulatedEarningsSmoothFactor = accumulatedEarningsSmoothFactor_;\\n    emit AccumulatedEarningsSmoothFactorSet(accumulatedEarningsSmoothFactor_);\\n  }\\n\\n  /// @notice Sets the interest rate model to be used to calculate rates.\\n  /// @param interestRateModel_ new interest rate model.\\n  function setInterestRateModel(InterestRateModel interestRateModel_) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    interestRateModel = interestRateModel_;\\n    emit InterestRateModelSet(interestRateModel_);\\n  }\\n\\n  /// @notice Sets the penalty rate per second.\\n  /// @dev Value can only be set approximately between 5% and 1% daily.\\n  /// @param penaltyRate_ percentage represented with 18 decimals.\\n  function setPenaltyRate(uint256 penaltyRate_) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    if (penaltyRate_ > 5.79e11 || penaltyRate_ < 1.15e11) revert InvalidParameter();\\n    penaltyRate = penaltyRate_;\\n    emit PenaltyRateSet(penaltyRate_);\\n  }\\n\\n  /// @notice Sets the percentage that represents the smart pool liquidity reserves that can't be borrowed.\\n  /// @dev Value can only be set between 20% and 0%.\\n  /// @param smartPoolReserveFactor_ parameter represented with 18 decimals.\\n  function setSmartPoolReserveFactor(uint128 smartPoolReserveFactor_) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    if (smartPoolReserveFactor_ > 0.2e18) revert InvalidParameter();\\n    smartPoolReserveFactor = smartPoolReserveFactor_;\\n    emit SmartPoolReserveFactorSet(smartPoolReserveFactor_);\\n  }\\n\\n  /// @notice Sets the damp speed used to update the smartPoolAssetsAverage.\\n  /// @dev Values can only be set between 0 and 100%.\\n  /// @param dampSpeed represented with 18 decimals.\\n  function setDampSpeed(DampSpeed memory dampSpeed) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    if (dampSpeed.up > 1e18 || dampSpeed.down > 1e18) revert InvalidParameter();\\n    dampSpeedUp = dampSpeed.up;\\n    dampSpeedDown = dampSpeed.down;\\n    emit DampSpeedSet(dampSpeed.up, dampSpeed.down);\\n  }\\n\\n  /// @notice Sets the _pause state to true in case of emergency, triggered by an authorized account.\\n  function pause() external onlyRole(PAUSER_ROLE) {\\n    _pause();\\n  }\\n\\n  /// @notice Sets the _pause state to false when threat is gone, triggered by an authorized account.\\n  function unpause() external onlyRole(PAUSER_ROLE) {\\n    _unpause();\\n  }\\n\\n  /// @notice Liquidates undercollateralized position(s).\\n  /// @dev Msg.sender liquidates borrower's position(s) and repays a certain amount of debt for multiple maturities,\\n  /// seizing a part of borrower's collateral.\\n  /// @param borrower wallet that has an outstanding debt across all maturities.\\n  /// @param maxAssets maximum amount of debt that the liquidator is willing to accept. (it can be less)\\n  /// @param collateralMarket fixedLender from which the collateral will be seized to give the liquidator.\\n  function liquidate(\\n    address borrower,\\n    uint256 maxAssets,\\n    FixedLender collateralMarket\\n  ) external nonReentrant whenNotPaused returns (uint256 repaidAssets) {\\n    if (msg.sender == borrower) revert SelfLiquidation();\\n\\n    bool moreCollateral;\\n    (maxAssets, moreCollateral) = auditor.checkLiquidation(this, collateralMarket, borrower, maxAssets);\\n    if (maxAssets == 0) revert ZeroRepay();\\n\\n    uint256 packedMaturities = fixedBorrows[borrower];\\n    uint256 baseMaturity = packedMaturities % (1 << 32);\\n    packedMaturities = packedMaturities >> 32;\\n    for (uint256 i = 0; i < 224; ) {\\n      if ((packedMaturities & (1 << i)) != 0) {\\n        uint256 maturity = baseMaturity + (i * TSUtils.INTERVAL);\\n        if (maxAssets > 0) {\\n          uint256 actualRepay;\\n          if (block.timestamp < maturity) {\\n            actualRepay = noTransferRepay(maturity, maxAssets, maxAssets, borrower, false);\\n            maxAssets -= actualRepay;\\n          } else {\\n            uint256 position;\\n            {\\n              PoolLib.Position memory p = fixedBorrowPositions[maturity][borrower];\\n              position = p.principal + p.fee;\\n            }\\n            uint256 debt = position + position.mulWadDown((block.timestamp - maturity) * penaltyRate);\\n            actualRepay = debt > maxAssets ? maxAssets.mulDivDown(position, debt) : maxAssets;\\n\\n            if (actualRepay == 0) maxAssets = 0;\\n            else {\\n              actualRepay = noTransferRepay(maturity, actualRepay, maxAssets, borrower, false);\\n              maxAssets -= actualRepay;\\n\\n              {\\n                PoolLib.Position memory p = fixedBorrowPositions[maturity][borrower];\\n                position = p.principal + p.fee;\\n              }\\n              debt = position + position.mulWadDown((block.timestamp - maturity) * penaltyRate);\\n              if ((debt > maxAssets ? maxAssets.mulDivDown(position, debt) : maxAssets) == 0) maxAssets = 0;\\n            }\\n          }\\n          repaidAssets += actualRepay;\\n\\n          if ((1 << (i + 1)) > packedMaturities) maxAssets = 0;\\n\\n          if (maxAssets == 0) {\\n            // reverts on failure\\n            (uint256 seizeAssets, uint256 lendersAssets) = auditor.liquidateCalculateSeizeAmount(\\n              this,\\n              collateralMarket,\\n              borrower,\\n              repaidAssets\\n            );\\n\\n            moreCollateral =\\n              (\\n                // if this is also the collateral run `_seize` to avoid re-entrancy, otherwise make an external call.\\n                // both revert on failure\\n                address(collateralMarket) == address(this)\\n                  ? _seize(this, msg.sender, borrower, seizeAssets)\\n                  : collateralMarket.seize(msg.sender, borrower, seizeAssets)\\n              ) ||\\n              moreCollateral;\\n\\n            emit LiquidateBorrow(msg.sender, borrower, repaidAssets, lendersAssets, collateralMarket, seizeAssets);\\n\\n            asset.safeTransferFrom(msg.sender, address(this), repaidAssets + lendersAssets);\\n          }\\n        }\\n\\n        if (maxAssets == 0 && !moreCollateral) {\\n          PoolLib.Position memory position = fixedBorrowPositions[maturity][borrower];\\n          uint256 debt = position.principal + position.fee;\\n          if (debt > 0) {\\n            smartPoolBorrowed -= fixedPools[maturity].repay(position.principal);\\n\\n            {\\n              uint256 memEarningsAccumulator = smartPoolEarningsAccumulator;\\n              uint256 fromAccumulator = Math.min(memEarningsAccumulator, debt);\\n              smartPoolEarningsAccumulator = memEarningsAccumulator - fromAccumulator;\\n              if (fromAccumulator < debt) smartPoolAssets -= debt - fromAccumulator;\\n            }\\n\\n            delete fixedBorrowPositions[maturity][borrower];\\n            fixedBorrows[borrower] = fixedBorrows[borrower].clearMaturity(maturity);\\n          }\\n        }\\n      }\\n\\n      unchecked {\\n        ++i;\\n      }\\n      if ((1 << i) > packedMaturities) break;\\n    }\\n  }\\n\\n  /// @notice Public function to seize a certain amount of tokens.\\n  /// @dev Public function for liquidator to seize borrowers tokens in the smart pool.\\n  /// This function will only be called from another FixedLender, on `liquidation` calls.\\n  /// That's why msg.sender needs to be passed to the private function (to be validated as a market)\\n  /// @param liquidator address which will receive the seized tokens.\\n  /// @param borrower address from which the tokens will be seized.\\n  /// @param assets amount to be removed from borrower's possession.\\n  function seize(\\n    address liquidator,\\n    address borrower,\\n    uint256 assets\\n  ) external nonReentrant whenNotPaused returns (bool) {\\n    return _seize(FixedLender(msg.sender), liquidator, borrower, assets);\\n  }\\n\\n  /// @dev Borrows a certain amount from a maturity date.\\n  /// @param maturity maturity date for repayment.\\n  /// @param assets amount to send to borrower.\\n  /// @param maxAssets maximum amount of debt that the user is willing to accept.\\n  /// @param receiver address that will receive the borrowed assets.\\n  /// @param borrower address that will repay the borrowed assets.\\n  function borrowAtMaturity(\\n    uint256 maturity,\\n    uint256 assets,\\n    uint256 maxAssets,\\n    address receiver,\\n    address borrower\\n  ) public nonReentrant whenNotPaused returns (uint256 assetsOwed) {\\n    // reverts on failure\\n    TSUtils.validateRequiredPoolState(maxFuturePools, maturity, TSUtils.State.VALID, TSUtils.State.NONE);\\n\\n    PoolLib.FixedPool storage pool = fixedPools[maturity];\\n\\n    uint256 earningsSP = pool.accrueEarnings(maturity, block.timestamp);\\n\\n    updateSmartPoolAssetsAverage();\\n    uint256 fee = assets.mulWadDown(\\n      interestRateModel.getRateToBorrow(\\n        maturity,\\n        block.timestamp,\\n        assets,\\n        pool.borrowed,\\n        pool.supplied,\\n        smartPoolAssetsAverage\\n      )\\n    );\\n    assetsOwed = assets + fee;\\n\\n    {\\n      uint256 memSPAssets = smartPoolAssets;\\n      uint256 memSPBorrowed = smartPoolBorrowed;\\n      memSPBorrowed += pool.borrow(assets, memSPAssets - memSPBorrowed);\\n\\n      if (memSPBorrowed > memSPAssets.mulWadDown(1e18 - smartPoolReserveFactor)) revert SmartPoolReserveExceeded();\\n\\n      smartPoolBorrowed = memSPBorrowed;\\n    }\\n\\n    // We validate that the user is not taking arbitrary fees\\n    if (assetsOwed > maxAssets) revert TooMuchSlippage();\\n\\n    if (msg.sender != borrower) {\\n      uint256 allowed = allowance[borrower][msg.sender]; // saves gas for limited approvals.\\n\\n      if (allowed != type(uint256).max) allowance[borrower][msg.sender] = allowed - previewWithdraw(assetsOwed);\\n    }\\n\\n    // If user doesn't have a current position, we add it to the list of all of them\\n    PoolLib.Position memory position = fixedBorrowPositions[maturity][borrower];\\n    if (position.principal == 0) {\\n      fixedBorrows[borrower] = fixedBorrows[borrower].setMaturity(maturity);\\n    }\\n\\n    // We calculate what portion of the fees are to be accrued and what portion goes to earnings accumulator\\n    (uint256 newUnassignedEarnings, uint256 newEarningsSP) = PoolLib.distributeEarningsAccordingly(\\n      fee,\\n      pool.smartPoolBorrowed(),\\n      assets\\n    );\\n    smartPoolEarningsAccumulator += newEarningsSP;\\n    pool.earningsUnassigned += newUnassignedEarnings;\\n\\n    fixedBorrowPositions[maturity][borrower] = PoolLib.Position(position.principal + assets, position.fee + fee);\\n\\n    {\\n      uint256 memSPAssets = smartPoolAssets;\\n      emit SmartPoolEarningsAccrued(memSPAssets, earningsSP);\\n      smartPoolAssets = memSPAssets + earningsSP;\\n    }\\n\\n    auditor.validateBorrow(this, borrower);\\n    asset.safeTransfer(receiver, assets);\\n\\n    emit BorrowAtMaturity(maturity, msg.sender, receiver, borrower, assets, fee);\\n    emit MarketUpdated(\\n      block.timestamp,\\n      totalSupply,\\n      smartPoolAssets,\\n      smartPoolEarningsAccumulator,\\n      maturity,\\n      pool.earningsUnassigned\\n    );\\n  }\\n\\n  /// @notice Deposits a certain amount to a maturity.\\n  /// @param maturity maturity date / pool ID.\\n  /// @param assets amount to receive from the msg.sender.\\n  /// @param minAssetsRequired minimum amount of assets required by the depositor for the transaction to be accepted.\\n  /// @param receiver address that will be able to withdraw the deposited assets.\\n  /// @return positionAssets total amount of assets (principal + fee) to be withdrawn at maturity.\\n  function depositAtMaturity(\\n    uint256 maturity,\\n    uint256 assets,\\n    uint256 minAssetsRequired,\\n    address receiver\\n  ) public nonReentrant whenNotPaused returns (uint256 positionAssets) {\\n    // reverts on failure\\n    TSUtils.validateRequiredPoolState(maxFuturePools, maturity, TSUtils.State.VALID, TSUtils.State.NONE);\\n\\n    PoolLib.FixedPool storage pool = fixedPools[maturity];\\n\\n    uint256 earningsSP = pool.accrueEarnings(maturity, block.timestamp);\\n\\n    (uint256 fee, uint256 feeSP) = interestRateModel.getYieldForDeposit(\\n      pool.smartPoolBorrowed(),\\n      pool.earningsUnassigned,\\n      assets\\n    );\\n    positionAssets = assets + fee;\\n    if (positionAssets < minAssetsRequired) revert TooMuchSlippage();\\n\\n    smartPoolBorrowed -= pool.deposit(assets);\\n    pool.earningsUnassigned -= fee + feeSP;\\n    smartPoolEarningsAccumulator += feeSP;\\n\\n    // We update user's position\\n    PoolLib.Position memory position = fixedDepositPositions[maturity][receiver];\\n\\n    // If user doesn't have a current position, we add it to the list of all of them\\n    if (position.principal == 0) {\\n      fixedDeposits[receiver] = fixedDeposits[receiver].setMaturity(maturity);\\n    }\\n\\n    fixedDepositPositions[maturity][receiver] = PoolLib.Position(position.principal + assets, position.fee + fee);\\n\\n    uint256 memSPAssets = smartPoolAssets;\\n    emit SmartPoolEarningsAccrued(memSPAssets, earningsSP);\\n    smartPoolAssets = memSPAssets + earningsSP;\\n\\n    emit DepositAtMaturity(maturity, msg.sender, receiver, assets, fee);\\n    emit MarketUpdated(\\n      block.timestamp,\\n      totalSupply,\\n      smartPoolAssets,\\n      smartPoolEarningsAccumulator,\\n      maturity,\\n      pool.earningsUnassigned\\n    );\\n\\n    asset.safeTransferFrom(msg.sender, address(this), assets);\\n  }\\n\\n  /// @notice Withdraws a certain amount from a maturity.\\n  /// @dev It's expected that this function can't be paused to prevent freezing user funds.\\n  /// @param maturity maturity date where the assets will be withdrawn.\\n  /// @param positionAssets the amount of assets (principal + fee) to be withdrawn.\\n  /// @param minAssetsRequired minimum amount required by the user (if discount included for early withdrawal).\\n  /// @param receiver address that will receive the withdrawn assets.\\n  /// @param owner address that previously deposited the assets.\\n  /// @return assetsDiscounted amount of assets withdrawn (can include a discount for early withdraw).\\n  function withdrawAtMaturity(\\n    uint256 maturity,\\n    uint256 positionAssets,\\n    uint256 minAssetsRequired,\\n    address receiver,\\n    address owner\\n  ) public nonReentrant returns (uint256 assetsDiscounted) {\\n    if (positionAssets == 0) revert ZeroWithdraw();\\n    // reverts on failure\\n    TSUtils.validateRequiredPoolState(maxFuturePools, maturity, TSUtils.State.VALID, TSUtils.State.MATURED);\\n\\n    PoolLib.FixedPool storage pool = fixedPools[maturity];\\n\\n    uint256 earningsSP = pool.accrueEarnings(maturity, block.timestamp);\\n\\n    PoolLib.Position memory position = fixedDepositPositions[maturity][owner];\\n\\n    if (positionAssets > position.principal + position.fee) positionAssets = position.principal + position.fee;\\n\\n    // We verify if there are any penalties/fee for him because of\\n    // early withdrawal - if so: discount\\n    if (block.timestamp < maturity) {\\n      updateSmartPoolAssetsAverage();\\n      assetsDiscounted = positionAssets.divWadDown(\\n        1e18 +\\n          interestRateModel.getRateToBorrow(\\n            maturity,\\n            block.timestamp,\\n            positionAssets,\\n            pool.borrowed,\\n            pool.supplied,\\n            smartPoolAssetsAverage\\n          )\\n      );\\n    } else {\\n      assetsDiscounted = positionAssets;\\n    }\\n\\n    if (assetsDiscounted < minAssetsRequired) revert TooMuchSlippage();\\n\\n    if (msg.sender != owner) {\\n      uint256 allowed = allowance[owner][msg.sender]; // saves gas for limited approvals.\\n\\n      if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - previewWithdraw(assetsDiscounted);\\n    }\\n\\n    // We remove the supply from the fixed rate pool\\n    smartPoolBorrowed += pool.withdraw(\\n      PoolLib.Position(position.principal, position.fee).scaleProportionally(positionAssets).principal,\\n      smartPoolAssets - smartPoolBorrowed\\n    );\\n\\n    // All the fees go to unassigned or to the smart pool\\n    (uint256 earningsUnassigned, uint256 newEarningsSP) = PoolLib.distributeEarningsAccordingly(\\n      positionAssets - assetsDiscounted,\\n      pool.smartPoolBorrowed(),\\n      assetsDiscounted\\n    );\\n    pool.earningsUnassigned += earningsUnassigned;\\n    smartPoolEarningsAccumulator += newEarningsSP;\\n\\n    // the user gets discounted the full amount\\n    position.reduceProportionally(positionAssets);\\n    if (position.principal + position.fee == 0) {\\n      delete fixedDepositPositions[maturity][owner];\\n      fixedDeposits[owner] = fixedDeposits[owner].clearMaturity(maturity);\\n    } else {\\n      // we proportionally reduce the values\\n      fixedDepositPositions[maturity][owner] = position;\\n    }\\n\\n    uint256 memSPAssets = smartPoolAssets;\\n    emit SmartPoolEarningsAccrued(memSPAssets, earningsSP);\\n    smartPoolAssets = memSPAssets + earningsSP;\\n\\n    asset.safeTransfer(receiver, assetsDiscounted);\\n\\n    emit WithdrawAtMaturity(maturity, msg.sender, receiver, owner, positionAssets, assetsDiscounted);\\n    emit MarketUpdated(\\n      block.timestamp,\\n      totalSupply,\\n      smartPoolAssets,\\n      smartPoolEarningsAccumulator,\\n      maturity,\\n      pool.earningsUnassigned\\n    );\\n  }\\n\\n  /// @notice Repays a certain amount to a maturity.\\n  /// @param maturity maturity date where the assets will be repaid.\\n  /// @param positionAssets amount to be paid for the borrower's debt.\\n  /// @param maxAssets maximum amount of debt that the user is willing to accept to be repaid.\\n  /// @param borrower address of the account that has the debt.\\n  /// @return actualRepayAssets the actual amount that was transferred into the protocol.\\n  function repayAtMaturity(\\n    uint256 maturity,\\n    uint256 positionAssets,\\n    uint256 maxAssets,\\n    address borrower\\n  ) public nonReentrant whenNotPaused returns (uint256 actualRepayAssets) {\\n    // reverts on failure\\n    TSUtils.validateRequiredPoolState(maxFuturePools, maturity, TSUtils.State.VALID, TSUtils.State.MATURED);\\n\\n    actualRepayAssets = noTransferRepay(maturity, positionAssets, maxAssets, borrower, true);\\n    asset.safeTransferFrom(msg.sender, address(this), actualRepayAssets);\\n  }\\n\\n  /// @notice This function allows to (partially) repay a position. It does not transfer tokens.\\n  /// @dev Internal repay function, allows partial repayment.\\n  /// @param maturity the maturity to access the pool.\\n  /// @param positionAssets the amount of debt of the pool that should be paid.\\n  /// @param maxAssets maximum amount of debt that the user is willing to accept to be repaid.\\n  /// @param borrower the address of the account that has the debt.\\n  /// @return actualRepayAssets the actual amount that should be transferred into the protocol.\\n  function noTransferRepay(\\n    uint256 maturity,\\n    uint256 positionAssets,\\n    uint256 maxAssets,\\n    address borrower,\\n    bool canDiscount\\n  ) internal returns (uint256 actualRepayAssets) {\\n    if (positionAssets == 0) revert ZeroRepay();\\n\\n    PoolLib.FixedPool storage pool = fixedPools[maturity];\\n\\n    uint256 earningsSP = pool.accrueEarnings(maturity, block.timestamp);\\n\\n    PoolLib.Position memory position = fixedBorrowPositions[maturity][borrower];\\n\\n    uint256 debtCovered = Math.min(positionAssets, position.principal + position.fee);\\n\\n    PoolLib.Position memory scaleDebtCovered = PoolLib.Position(position.principal, position.fee).scaleProportionally(\\n      debtCovered\\n    );\\n\\n    // Early repayment allows you to get a discount from the unassigned earnings\\n    if (block.timestamp < maturity) {\\n      if (canDiscount) {\\n        // We calculate the deposit fee considering the amount of debt the user'll pay\\n        (uint256 discountFee, uint256 feeSP) = interestRateModel.getYieldForDeposit(\\n          pool.smartPoolBorrowed(),\\n          pool.earningsUnassigned,\\n          scaleDebtCovered.principal\\n        );\\n\\n        // We remove the fee from unassigned earnings\\n        pool.earningsUnassigned -= discountFee + feeSP;\\n\\n        // The fee charged to the MP supplier go to the smart pool accumulator\\n        smartPoolEarningsAccumulator += feeSP;\\n\\n        // The fee gets discounted from the user through `repayAmount`\\n        actualRepayAssets = debtCovered - discountFee;\\n      } else {\\n        actualRepayAssets = debtCovered;\\n      }\\n    } else {\\n      actualRepayAssets = debtCovered + debtCovered.mulWadDown((block.timestamp - maturity) * penaltyRate);\\n\\n      // All penalties go to the smart pool accumulator\\n      smartPoolEarningsAccumulator += actualRepayAssets - debtCovered;\\n    }\\n\\n    // We verify that the user agrees to this discount or penalty\\n    if (actualRepayAssets > maxAssets) revert TooMuchSlippage();\\n\\n    // We reduce the borrowed and we might decrease the SP debt\\n    smartPoolBorrowed -= pool.repay(scaleDebtCovered.principal);\\n\\n    // We update the user position\\n    position.reduceProportionally(debtCovered);\\n    if (position.principal + position.fee == 0) {\\n      delete fixedBorrowPositions[maturity][borrower];\\n      fixedBorrows[borrower] = fixedBorrows[borrower].clearMaturity(maturity);\\n    } else {\\n      // We proportionally reduce the values\\n      fixedBorrowPositions[maturity][borrower] = position;\\n    }\\n\\n    uint256 memSPAssets = smartPoolAssets;\\n    emit SmartPoolEarningsAccrued(memSPAssets, earningsSP);\\n    smartPoolAssets = memSPAssets + earningsSP;\\n\\n    emit RepayAtMaturity(maturity, msg.sender, borrower, actualRepayAssets, debtCovered);\\n    emit MarketUpdated(\\n      block.timestamp,\\n      totalSupply,\\n      smartPoolAssets,\\n      smartPoolEarningsAccumulator,\\n      maturity,\\n      pool.earningsUnassigned\\n    );\\n  }\\n\\n  /// @notice Internal function to seize a certain amount of tokens.\\n  /// @dev Internal function for liquidator to seize borrowers tokens in the smart pool.\\n  /// Will only be called from this FixedLender on `liquidation` or through `seize` calls from another FixedLender.\\n  /// That's why msg.sender needs to be passed to the internal function (to be validated as a market).\\n  /// @param seizerFixedLender address which is calling the seize function (see `seize` public function).\\n  /// @param liquidator address which will receive the seized tokens.\\n  /// @param borrower address from which the tokens will be seized.\\n  /// @param assets amount to be removed from borrower's possession.\\n  function _seize(\\n    FixedLender seizerFixedLender,\\n    address liquidator,\\n    address borrower,\\n    uint256 assets\\n  ) internal returns (bool moreCollateral) {\\n    if (assets == 0) revert ZeroWithdraw();\\n\\n    // reverts on failure\\n    auditor.checkSeize(this, seizerFixedLender);\\n\\n    uint256 shares = previewWithdraw(assets);\\n    beforeWithdraw(assets, shares);\\n    _burn(borrower, shares);\\n    emit Withdraw(msg.sender, liquidator, borrower, assets, shares);\\n\\n    asset.safeTransfer(liquidator, assets);\\n    emit AssetSeized(liquidator, borrower, assets);\\n    emit MarketUpdated(block.timestamp, totalSupply, smartPoolAssets, smartPoolEarningsAccumulator, 0, 0);\\n\\n    return balanceOf[borrower] > 0;\\n  }\\n\\n  /// @notice Gets current snapshot for an account across all maturities.\\n  /// @param account account to return status snapshot in the specified maturity date.\\n  /// @return the amount the user deposited to the smart pool and the total money he owes from maturities.\\n  function getAccountSnapshot(address account) public view returns (uint256, uint256) {\\n    return (convertToAssets(balanceOf[account]), getDebt(account));\\n  }\\n\\n  /// @dev Gets all borrows and penalties for an account.\\n  /// @param account account to return status snapshot in the specified maturity date.\\n  /// @return debt the total debt, denominated in number of tokens.\\n  function getDebt(address account) public view returns (uint256 debt) {\\n    uint256 memPenaltyRate = penaltyRate;\\n    uint256 packedMaturities = fixedBorrows[account];\\n    uint256 baseMaturity = packedMaturities % (1 << 32);\\n    packedMaturities = packedMaturities >> 32;\\n    // calculate all maturities using the baseMaturity and the following bits representing the following intervals\\n    for (uint256 i = 0; i < 224; ) {\\n      if ((packedMaturities & (1 << i)) != 0) {\\n        uint256 maturity = baseMaturity + (i * TSUtils.INTERVAL);\\n        PoolLib.Position memory position = fixedBorrowPositions[maturity][account];\\n        uint256 positionAssets = position.principal + position.fee;\\n\\n        debt += positionAssets;\\n\\n        uint256 secondsDelayed = TSUtils.secondsPre(maturity, block.timestamp);\\n        if (secondsDelayed > 0) debt += positionAssets.mulWadDown(secondsDelayed * memPenaltyRate);\\n      }\\n\\n      unchecked {\\n        ++i;\\n      }\\n      if ((1 << i) > packedMaturities) break;\\n    }\\n  }\\n\\n  /// @notice Updates the smartPoolAssetsAverage.\\n  function updateSmartPoolAssetsAverage() internal {\\n    uint256 memSmartPoolAssets = smartPoolAssets;\\n    uint256 memSmartPoolAssetsAverage = smartPoolAssetsAverage;\\n    uint256 dampSpeedFactor = memSmartPoolAssets < memSmartPoolAssetsAverage ? dampSpeedDown : dampSpeedUp;\\n    uint256 averageFactor = uint256(1e18 - (-int256(dampSpeedFactor * (block.timestamp - lastAverageUpdate))).expWad());\\n    smartPoolAssetsAverage =\\n      memSmartPoolAssetsAverage.mulWadDown(1e18 - averageFactor) +\\n      averageFactor.mulWadDown(memSmartPoolAssets);\\n    lastAverageUpdate = uint32(block.timestamp);\\n  }\\n}\\n\\nerror AlreadyInitialized();\\nerror NotFixedLender();\\nerror SelfLiquidation();\\nerror SmartPoolReserveExceeded();\\nerror TooMuchSlippage();\\nerror ZeroWithdraw();\\nerror ZeroRepay();\\n\",\"keccak256\":\"0xabbc239d2303c1054a030b6b9000609e04f218e8e2849d5de0bae761d1b6366b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/FixedLenderETHRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\nimport { WETH, SafeTransferLib } from \\\"@rari-capital/solmate/src/tokens/WETH.sol\\\";\\nimport { FixedLender } from \\\"./FixedLender.sol\\\";\\n\\ncontract FixedLenderETHRouter {\\n  using SafeTransferLib for address;\\n\\n  FixedLender public immutable fixedLender;\\n  WETH public immutable weth;\\n\\n  modifier wrap() {\\n    weth.deposit{ value: msg.value }();\\n    _;\\n  }\\n\\n  modifier unwrap(uint256 assets, address receiver) {\\n    _;\\n    unwrapAndTransfer(assets, receiver);\\n  }\\n\\n  constructor(FixedLender fixedLender_) {\\n    fixedLender = fixedLender_;\\n    weth = WETH(payable(address(fixedLender_.asset())));\\n    weth.approve(address(fixedLender_), type(uint256).max);\\n  }\\n\\n  receive() external payable {\\n    if (msg.sender != address(weth)) revert NotFromWETH();\\n  }\\n\\n  function depositETH() public payable wrap returns (uint256 shares) {\\n    shares = fixedLender.deposit(msg.value, msg.sender);\\n  }\\n\\n  function withdrawETH(uint256 assets) external unwrap(assets, msg.sender) returns (uint256 shares) {\\n    shares = fixedLender.withdraw(assets, address(this), msg.sender);\\n  }\\n\\n  function depositAtMaturityETH(uint256 maturity, uint256 minAssetsRequired)\\n    external\\n    payable\\n    wrap\\n    returns (uint256 maturityAssets)\\n  {\\n    return fixedLender.depositAtMaturity(maturity, msg.value, minAssetsRequired, msg.sender);\\n  }\\n\\n  function withdrawAtMaturityETH(\\n    uint256 maturity,\\n    uint256 assets,\\n    uint256 minAssetsRequired\\n  ) external returns (uint256 actualAssets) {\\n    actualAssets = fixedLender.withdrawAtMaturity(maturity, assets, minAssetsRequired, address(this), msg.sender);\\n    unwrapAndTransfer(actualAssets, msg.sender);\\n  }\\n\\n  function borrowAtMaturityETH(\\n    uint256 maturity,\\n    uint256 assets,\\n    uint256 maxAssetsAllowed\\n  ) external unwrap(assets, msg.sender) returns (uint256 assetsOwed) {\\n    return fixedLender.borrowAtMaturity(maturity, assets, maxAssetsAllowed, address(this), msg.sender);\\n  }\\n\\n  function repayAtMaturityETH(uint256 maturity, uint256 assets) external payable wrap returns (uint256 repaidAssets) {\\n    repaidAssets = fixedLender.repayAtMaturity(maturity, assets, msg.value, msg.sender);\\n\\n    if (msg.value > repaidAssets) unwrapAndTransfer(msg.value - repaidAssets, msg.sender);\\n  }\\n\\n  function unwrapAndTransfer(uint256 assets, address receiver) internal {\\n    weth.withdraw(assets);\\n    receiver.safeTransferETH(assets);\\n  }\\n}\\n\\nerror NotFromWETH();\\n\",\"keccak256\":\"0xa749bc6c06b03f8467de79b071e6ce623a6b34f8bd848323c79b879a6991d7d5\",\"license\":\"GPL-3.0-or-later\"},\"contracts/InterestRateModel.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { AccessControl } from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport { FixedPointMathLib } from \\\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\nimport { InvalidParameter } from \\\"./Auditor.sol\\\";\\n\\ncontract InterestRateModel is AccessControl {\\n  using FixedPointMathLib for uint256;\\n  using FixedPointMathLib for int256;\\n\\n  // Parameters to the system, expressed with 1e18 decimals\\n  uint256 public curveParameterA;\\n  int256 public curveParameterB;\\n  uint256 public maxUtilization;\\n  uint256 public fullUtilization;\\n  uint256 public spFeeRate;\\n\\n  /// @notice Emitted when the curve parameters are changed by admin.\\n  /// @param a new curve parameter A.\\n  /// @param b new curve parameter B.\\n  /// @param maxUtilization new max utilization rate.\\n  /// @param fullUtilization new full utilization rate.\\n  event CurveParametersSet(uint256 a, int256 b, uint256 maxUtilization, uint256 fullUtilization);\\n\\n  /// @notice Emitted when the spFeeRate parameter is changed by admin.\\n  /// @param spFeeRate rate charged to the mp suppliers to be accrued by the sp suppliers.\\n  event SpFeeRateSet(uint256 spFeeRate);\\n\\n  constructor(\\n    uint256 curveParameterA_,\\n    int256 curveParameterB_,\\n    uint256 maxUtilization_,\\n    uint256 fullUtilization_,\\n    uint256 spFeeRate_\\n  ) {\\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n\\n    setCurveParameters(curveParameterA_, curveParameterB_, maxUtilization_, fullUtilization_);\\n    setSPFeeRate(spFeeRate_);\\n  }\\n\\n  /// @notice Sets the rate charged to the mp depositors that the sp suppliers will retain for initially providing\\n  /// liquidity.\\n  /// @dev Value can only be set between 20% and 0%.\\n  /// @param spFeeRate_ percentage amount represented with 1e18 decimals.\\n  function setSPFeeRate(uint256 spFeeRate_) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    if (spFeeRate_ > 0.2e18) revert InvalidParameter();\\n    spFeeRate = spFeeRate_;\\n    emit SpFeeRateSet(spFeeRate_);\\n  }\\n\\n  /// @notice Gets this model's curve parameters.\\n  /// @return parameters (curveA, curveB, maxUtilization, fullUtilization).\\n  function getCurveParameters()\\n    external\\n    view\\n    returns (\\n      uint256,\\n      int256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    return (curveParameterA, curveParameterB, maxUtilization, fullUtilization);\\n  }\\n\\n  /// @notice Calculates the amount of revenue sharing between the smart pool and the new MP supplier.\\n  /// @param suppliedSP amount of money currently being supplied in the fixed rate pool.\\n  /// @param unassignedEarnings earnings not yet accrued to the SP that should be shared with the current supplier.\\n  /// @param amount amount being provided by the MP supplier.\\n  /// @return earningsShare yield to be offered to the MP supplier.\\n  /// @return earningsShareSP yield to be accrued by the SP suppliers for initially providing the liquidity.\\n  function getYieldForDeposit(\\n    uint256 suppliedSP,\\n    uint256 unassignedEarnings,\\n    uint256 amount\\n  ) external view returns (uint256 earningsShare, uint256 earningsShareSP) {\\n    if (suppliedSP != 0) {\\n      // User can't make more fees after the total borrowed amount\\n      earningsShare = unassignedEarnings.mulDivDown(Math.min(amount, suppliedSP), suppliedSP);\\n      earningsShareSP = earningsShare.mulWadDown(spFeeRate);\\n      earningsShare -= earningsShareSP;\\n    }\\n  }\\n\\n  /// @notice Updates this model's curve parameters.\\n  /// @dev FullUR can only be between 1 and 52. UMaxUR can only be higher than FullUR and at most 3 times FullUR.\\n  /// @param curveParameterA_ curve parameter A.\\n  /// @param curveParameterB_ curve parameter B.\\n  /// @param maxUtilization_ % of MP supp.\\n  /// @param fullUtilization_ full UR.\\n  function setCurveParameters(\\n    uint256 curveParameterA_,\\n    int256 curveParameterB_,\\n    uint256 maxUtilization_,\\n    uint256 fullUtilization_\\n  ) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n    if (\\n      fullUtilization_ > 52e18 ||\\n      fullUtilization_ < 1e18 ||\\n      fullUtilization_ >= maxUtilization_ ||\\n      fullUtilization_ < maxUtilization_ / 3\\n    ) revert InvalidParameter();\\n\\n    curveParameterA = curveParameterA_;\\n    curveParameterB = curveParameterB_;\\n    maxUtilization = maxUtilization_;\\n    fullUtilization = fullUtilization_;\\n\\n    // reverts if it's an invalid curve (such as one yielding a negative interest rate).\\n    // doing it works because it's a monotonously increasing function.\\n    rate(0, 0);\\n\\n    emit CurveParametersSet(curveParameterA_, curveParameterB_, maxUtilization_, fullUtilization_);\\n  }\\n\\n  /// @notice Gets fee to borrow a certain amount at a certain maturity with supply/demand values in the fixed rate pool\\n  /// and supply/demand values in the smart pool.\\n  /// @param maturity maturity date for calculating days left to maturity.\\n  /// @param currentDate the current block timestamp. Received from caller for easier testing.\\n  /// @param amount the current borrow's amount.\\n  /// @param borrowedMP ex-ante amount borrowed from this maturity.\\n  /// @param suppliedMP deposits in the fixed rate pool.\\n  /// @param smartPoolAssetsAverage the average of the smart pool's assets.\\n  /// @return fee the borrower will have to pay, as a factor (1% interest is represented as the wad for 0.01 == 10^16).\\n  function getRateToBorrow(\\n    uint256 maturity,\\n    uint256 currentDate,\\n    uint256 amount,\\n    uint256 borrowedMP,\\n    uint256 suppliedMP,\\n    uint256 smartPoolAssetsAverage\\n  ) public view returns (uint256) {\\n    if (currentDate >= maturity) revert AlreadyMatured();\\n\\n    uint256 supplied = suppliedMP + smartPoolAssetsAverage.divWadDown(fullUtilization);\\n    uint256 utilizationBefore = borrowedMP.divWadDown(supplied);\\n    uint256 utilizationAfter = (borrowedMP + amount).divWadDown(supplied);\\n\\n    if (utilizationAfter > fullUtilization) revert UtilizationExceeded();\\n\\n    return rate(utilizationBefore, utilizationAfter).mulDivDown(maturity - currentDate, 365 days);\\n  }\\n\\n  /// @notice Returns the interest rate integral from `u0` to `u1`, using the analytical solution (ln).\\n  /// @dev handles special case where delta utilization tends to zero, using l'h\\u00f4pital's rule.\\n  /// @param utilizationBefore ex-ante utilization rate, with 18 decimals precision.\\n  /// @param utilizationAfter ex-post utilization rate, with 18 decimals precision.\\n  /// @return the interest rate, with 18 decimals precision.\\n  function rate(uint256 utilizationBefore, uint256 utilizationAfter) internal view returns (uint256) {\\n    int256 r = int256(\\n      utilizationAfter - utilizationBefore < 2.5e9\\n        ? curveParameterA.divWadDown(maxUtilization - utilizationBefore)\\n        : curveParameterA.mulDivDown(\\n          uint256(int256((maxUtilization - utilizationBefore).divWadDown(maxUtilization - utilizationAfter)).lnWad()),\\n          utilizationAfter - utilizationBefore\\n        )\\n    ) + curveParameterB;\\n    assert(r >= 0);\\n    return uint256(r);\\n  }\\n}\\n\\nerror AlreadyMatured();\\nerror InvalidAmount();\\nerror UtilizationExceeded();\\n\",\"keccak256\":\"0xd9b04798b55fe50b8903eb236dcc81168ee26063381bf2ba1c60756661911b7f\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/PoolLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\nimport { FixedPointMathLib } from \\\"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { TSUtils } from \\\"./TSUtils.sol\\\";\\n\\nlibrary PoolLib {\\n  using FixedPointMathLib for uint256;\\n\\n  /// @notice contains the accountability of a fixed interest rate pool.\\n  /// @param borrowed total amount borrowed from the pool.\\n  /// @param supplied total amount supplied to the pool.\\n  /// @param earningsUnassigned total amount of earnings not yet distributed and accrued.\\n  /// @param lastAccrual timestamp for the last time that some earnings have been distributed to earningsSP.\\n  struct FixedPool {\\n    uint256 borrowed;\\n    uint256 supplied;\\n    uint256 earningsUnassigned;\\n    uint256 lastAccrual;\\n  }\\n\\n  /// @notice contains principal and fee of a borrow or a supply position of a user in a fixed rate pool.\\n  /// @param principal amount borrowed or supplied to the fixed rate pool.\\n  /// @param fee amount of fees to be repaid or earned at the maturity of the fixed rate pool.\\n  struct Position {\\n    uint256 principal;\\n    uint256 fee;\\n  }\\n\\n  /// @notice calculates the amount that a fixed rate pool borrowed from the smart pool.\\n  /// @param pool fixed rate pool.\\n  /// @return amount borrowed from the fixed rate pool.\\n  function smartPoolBorrowed(FixedPool storage pool) internal view returns (uint256) {\\n    uint256 borrowed = pool.borrowed;\\n    uint256 supplied = pool.supplied;\\n    return borrowed - Math.min(borrowed, supplied);\\n  }\\n\\n  /// @notice registers an operation to add supply to a fixed rate pool and potentially reduce smart pool debt.\\n  /// @param pool fixed rate pool where an amount will be added to the supply.\\n  /// @param amount amount to be added to the supply.\\n  /// @return smartPoolDebtReduction amount that will be reduced from the smart pool debt.\\n  function deposit(FixedPool storage pool, uint256 amount) internal returns (uint256 smartPoolDebtReduction) {\\n    uint256 borrowed = pool.borrowed;\\n    uint256 supplied = pool.supplied;\\n    pool.supplied = supplied + amount;\\n    smartPoolDebtReduction = Math.min(borrowed - Math.min(borrowed, supplied), amount);\\n  }\\n\\n  /// @notice registers an operation to reduce borrowed amount from a fixed rate pool\\n  /// and potentially reduce smart pool debt.\\n  /// @param pool fixed rate pool where an amount will be repaid.\\n  /// @param amount amount to be added to the fixed rate pool.\\n  /// @return smartPoolDebtReduction amount that will be reduced from the smart pool debt.\\n  function repay(FixedPool storage pool, uint256 amount) internal returns (uint256 smartPoolDebtReduction) {\\n    uint256 borrowed = pool.borrowed;\\n    uint256 supplied = pool.supplied;\\n    pool.borrowed = borrowed - amount;\\n    smartPoolDebtReduction = Math.min(borrowed - Math.min(borrowed, supplied), amount);\\n  }\\n\\n  /// @notice registers an operation to increase borrowed amount of a fixed rate pool\\n  ///  and potentially increase smart pool debt.\\n  /// @param pool fixed rate pool where an amount will be borrowed.\\n  /// @param amount amount to be borrowed from the fixed rate pool.\\n  /// @return smartPoolDebtAddition amount of new debt that needs to be borrowed from the smart pool.\\n  function borrow(\\n    FixedPool storage pool,\\n    uint256 amount,\\n    uint256 maxDebt\\n  ) internal returns (uint256 smartPoolDebtAddition) {\\n    uint256 borrowed = pool.borrowed;\\n    uint256 newBorrowed = borrowed + amount;\\n    uint256 oldSupply = Math.max(borrowed, pool.supplied);\\n\\n    smartPoolDebtAddition = newBorrowed - Math.min(oldSupply, newBorrowed);\\n\\n    if (smartPoolDebtAddition > maxDebt) revert InsufficientProtocolLiquidity();\\n\\n    pool.borrowed = newBorrowed;\\n  }\\n\\n  /// @notice registers an operation to reduce supply from a fixed rate pool and potentially increase smart pool debt.\\n  /// @param pool fixed rate pool where amount will be withdrawn.\\n  /// @param amountToDiscount amount to be withdrawn from the fixed rate pool.\\n  /// @return smartPoolDebtAddition amount of new debt that needs to be borrowed from the smart pool.\\n  function withdraw(\\n    FixedPool storage pool,\\n    uint256 amountToDiscount,\\n    uint256 maxDebt\\n  ) internal returns (uint256 smartPoolDebtAddition) {\\n    uint256 borrowed = pool.borrowed;\\n    uint256 supplied = pool.supplied;\\n    uint256 newSupply = supplied - amountToDiscount;\\n\\n    smartPoolDebtAddition = Math.min(supplied, borrowed) - Math.min(newSupply, borrowed);\\n\\n    if (smartPoolDebtAddition > maxDebt) revert InsufficientProtocolLiquidity();\\n\\n    pool.supplied = newSupply;\\n  }\\n\\n  /// @notice accrues smart pool earnings from earningsUnassigned based on the lastAccrual time.\\n  /// @param pool fixed rate pool where earnings will be accrued.\\n  /// @param currentTimestamp timestamp of the current transaction.\\n  /// @param maturity maturity date of the pool.\\n  /// @return earningsSP amount of earnings to be distributed to the smart pool.\\n  function accrueEarnings(\\n    FixedPool storage pool,\\n    uint256 maturity,\\n    uint256 currentTimestamp\\n  ) internal returns (uint256 earningsSP) {\\n    uint256 lastAccrual = pool.lastAccrual;\\n\\n    if (lastAccrual == maturity) return 0;\\n\\n    // seconds from last accrual to the closest:\\n    // maturity date or the current timestamp\\n    uint256 secondsSinceLastAccrue = TSUtils.secondsPre(lastAccrual, Math.min(maturity, currentTimestamp));\\n    // seconds from last accrual to the maturity date\\n    uint256 secondsTotalToMaturity = TSUtils.secondsPre(lastAccrual, maturity);\\n    pool.lastAccrual = Math.min(maturity, currentTimestamp);\\n\\n    // assign some of the earnings to be collected at maturity\\n    uint256 earningsUnassigned = pool.earningsUnassigned;\\n    earningsSP = earningsUnassigned.mulDivDown(secondsSinceLastAccrue, secondsTotalToMaturity);\\n    pool.earningsUnassigned = earningsUnassigned - earningsSP;\\n  }\\n\\n  /// @notice modify positions based on a certain amount, keeping the original principal/fee ratio.\\n  /// @dev modifies the original struct and returns it. Needs for the amount to be less than the principal and the fee\\n  /// @param position original position to be scaled.\\n  /// @param amount to be used as a full value (principal + interest).\\n  /// @return Position scaled position.\\n  function scaleProportionally(Position memory position, uint256 amount) internal pure returns (Position memory) {\\n    uint256 principal = amount.mulDivDown(position.principal, position.principal + position.fee);\\n    position.principal = principal;\\n    position.fee = amount - principal;\\n    return position;\\n  }\\n\\n  /// @notice reduce positions based on a certain amount, keeping the original principal/fee ratio.\\n  /// @dev modifies the original struct and returns it.\\n  /// @param position original position to be reduced.\\n  /// @param amount to be used as a full value (principal + interest).\\n  /// @return Position reduced position.\\n  function reduceProportionally(Position memory position, uint256 amount) internal pure returns (Position memory) {\\n    uint256 principal = amount.mulDivDown(position.principal, position.principal + position.fee);\\n    position.principal -= principal;\\n    position.fee -= amount - principal;\\n    return position;\\n  }\\n\\n  /// @notice calculates what proportion of earnings would amountFunded represent considering suppliedSP.\\n  /// @param earnings amount to be distributed.\\n  /// @param suppliedSP amount that the fixed rate pool borrowed from the smart pool.\\n  /// @param amountFunded amount that will be checked if came from the smart pool or fixed rate pool.\\n  /// @return earningsUnassigned earnings to be added to earningsUnassigned.\\n  /// @return earningsSP earnings to be distributed to the smart pool.\\n  function distributeEarningsAccordingly(\\n    uint256 earnings,\\n    uint256 suppliedSP,\\n    uint256 amountFunded\\n  ) internal pure returns (uint256 earningsUnassigned, uint256 earningsSP) {\\n    earningsSP = amountFunded == 0\\n      ? 0\\n      : earnings.mulDivDown(amountFunded - Math.min(suppliedSP, amountFunded), amountFunded);\\n    earningsUnassigned = earnings - earningsSP;\\n  }\\n\\n  /// @notice adds a maturity date to the borrow or supply positions of the user.\\n  /// @param encoded encoded maturity dates where the user borrowed or supplied to.\\n  /// @param maturity the new maturity where the user will borrow or supply to.\\n  /// @return updated encoded maturity dates.\\n  function setMaturity(uint256 encoded, uint256 maturity) internal pure returns (uint256) {\\n    // we initialize the maturity date with also the 1st bit on the 33th position set\\n    if (encoded == 0) return maturity | (1 << 32);\\n\\n    uint256 baseMaturity = encoded % (1 << 32);\\n    if (maturity < baseMaturity) {\\n      // If the new maturity date is lower than the base, then we need to set it as the new base. We wipe clean the\\n      // last 32 bits, we shift the amount of INTERVALS and we set the new value with the 33rd bit set\\n      uint256 range = (baseMaturity - maturity) / TSUtils.INTERVAL;\\n      if (encoded >> (256 - range) != 0) revert MaturityOverflow();\\n      encoded = ((encoded >> 32) << (32 + range));\\n      return maturity | encoded | (1 << 32);\\n    } else {\\n      uint256 range = (maturity - baseMaturity) / TSUtils.INTERVAL;\\n      if (range > 223) revert MaturityOverflow();\\n      return encoded | (1 << (32 + range));\\n    }\\n  }\\n\\n  /// @notice remove maturity from user's borrow or supplied positions.\\n  /// @param encoded encoded maturity dates where the user borrowed or supplied to.\\n  /// @param maturity maturity date to be removed.\\n  /// @return updated encoded maturity dates.\\n  function clearMaturity(uint256 encoded, uint256 maturity) internal pure returns (uint256) {\\n    if (encoded == 0 || encoded == maturity | (1 << 32)) return 0;\\n\\n    uint256 baseMaturity = encoded % (1 << 32);\\n    // if the baseMaturity is the one being cleaned\\n    if (maturity == baseMaturity) {\\n      // We're wiping 32 bytes + 1 for the old base flag\\n      uint256 packed = encoded >> 33;\\n      uint256 range = 1;\\n      while ((packed & 1) == 0 && packed != 0) {\\n        unchecked {\\n          ++range;\\n        }\\n        packed >>= 1;\\n      }\\n      encoded = ((encoded >> (32 + range)) << 32);\\n      return (maturity + (range * TSUtils.INTERVAL)) | encoded;\\n    } else {\\n      // otherwise just clear the bit\\n      return encoded & ~(1 << (32 + ((maturity - baseMaturity) / TSUtils.INTERVAL)));\\n    }\\n  }\\n\\n  /// @notice checks if the user has positions in a maturity date.\\n  /// @param encoded encoded maturity dates where the user borrowed or supplied to.\\n  /// @param maturity maturity date.\\n  /// @return true if the user has positions in the maturity date.\\n  function hasMaturity(uint256 encoded, uint256 maturity) internal pure returns (bool) {\\n    uint256 baseMaturity = encoded % (1 << 32);\\n    if (maturity < baseMaturity) return false;\\n\\n    uint256 range = (maturity - baseMaturity) / TSUtils.INTERVAL;\\n    if (range > 223) return false;\\n    return ((encoded >> 32) & (1 << range)) != 0;\\n  }\\n}\\n\\nerror InsufficientProtocolLiquidity();\\nerror MaturityOverflow();\\n\",\"keccak256\":\"0xceb42fc4343b439db74bfa8a2b8b190bff90add91526e3b0fe47eee93ea9a3d7\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/TSUtils.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\nlibrary TSUtils {\\n  enum State {\\n    NONE,\\n    INVALID,\\n    MATURED,\\n    VALID,\\n    NOT_READY\\n  }\\n\\n  uint32 public constant INTERVAL = 4 weeks;\\n\\n  /// @notice calculates how many seconds are left to a certain date.\\n  /// @param timestampFrom to calculate the difference in seconds from a date.\\n  /// @param timestampTo to calculate the difference in seconds to a date.\\n  /// @return seconds left to the date.\\n  function secondsPre(uint256 timestampFrom, uint256 timestampTo) internal pure returns (uint256) {\\n    return timestampFrom < timestampTo ? timestampTo - timestampFrom : 0;\\n  }\\n\\n  /// @notice returns a pool `time` state based on the current time, maxPools available, and INTERVAL.\\n  /// @param timestamp timestamp of the current time.\\n  /// @param maturity used as maturity date / pool id.\\n  /// @param maxPools number of pools available in the time horizon.\\n  /// @return state: if a pool is VALID, not yet available(NOT_READY), INVALID or MATURED.\\n  function getPoolState(\\n    uint256 timestamp,\\n    uint256 maturity,\\n    uint8 maxPools\\n  ) private pure returns (State) {\\n    if (maturity % INTERVAL != 0) return State.INVALID;\\n\\n    if (maturity <= timestamp) return State.MATURED;\\n\\n    if (maturity > timestamp - (timestamp % INTERVAL) + (INTERVAL * maxPools)) return State.NOT_READY;\\n\\n    return State.VALID;\\n  }\\n\\n  /// @notice verifies that a maturity is VALID, MATURED, NOT_READY or INVALID.\\n  /// @dev if expected state doesn't match the calculated one, it reverts with a custom error \\\"UnmatchedPoolState\\\".\\n  /// @param maturity timestamp of the maturity date to be verified.\\n  /// @param requiredState state required by the caller to be verified (see TSUtils.State() for description).\\n  /// @param alternativeState state required by the caller to be verified (see TSUtils.State() for description).\\n  function validateRequiredPoolState(\\n    uint8 maxFuturePools,\\n    uint256 maturity,\\n    State requiredState,\\n    State alternativeState\\n  ) internal view {\\n    State poolState = getPoolState(block.timestamp, maturity, maxFuturePools);\\n\\n    if (poolState != requiredState && poolState != alternativeState) {\\n      if (alternativeState == State.NONE) revert UnmatchedPoolState(uint8(poolState), uint8(requiredState));\\n\\n      revert UnmatchedPoolStateMultiple(uint8(poolState), uint8(requiredState), uint8(alternativeState));\\n    }\\n  }\\n}\\n\\nerror UnmatchedPoolState(uint8 state, uint8 requiredState);\\nerror UnmatchedPoolStateMultiple(uint8 state, uint8 requiredState, uint8 alternativeState);\\n\",\"keccak256\":\"0x3164707721594e1bf2d69a1aa45c43730595a0fa62ad236dfb0bc39939165cd6\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x60c060405234801561001057600080fd5b50604051610cdf380380610cdf83398101604081905261002f91610136565b6001600160a01b0381166080819052604080516338d52e0f60e01b815290516338d52e0f916004808201926020929091908290030181865afa158015610079573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061009d9190610136565b6001600160a01b0390811660a081905260405163095ea7b360e01b8152918316600483015260001960248301529063095ea7b3906044016020604051808303816000875af11580156100f3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610117919061015a565b505061017c565b6001600160a01b038116811461013357600080fd5b50565b60006020828403121561014857600080fd5b81516101538161011e565b9392505050565b60006020828403121561016c57600080fd5b8151801515811461015357600080fd5b60805160a051610af26101ed60003960008181609c0152818161013f0152818161030d015281816105600152818161078001526108ea0152600081816101ab01528181610274015281816103cb015281816104da0152818161061e015281816106fc01526108300152610af26000f3fe60806040526004361061007f5760003560e01c80639b283ed31161004e5780639b283ed3146101cd578063e46a66c0146101ed578063f14210a614610200578063f6326fb31461022057600080fd5b806321ce312e146100fa5780633fc8cef31461012d57806368c53694146101865780636bf1ad7a1461019957600080fd5b366100f5573373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146100f3576040517f61e790f900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b005b600080fd5b34801561010657600080fd5b5061011a6101153660046109fe565b610228565b6040519081526020015b60405180910390f35b34801561013957600080fd5b506101617f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610124565b61011a610194366004610a2a565b610309565b3480156101a557600080fd5b506101617f000000000000000000000000000000000000000000000000000000000000000081565b3480156101d957600080fd5b5061011a6101e83660046109fe565b610474565b61011a6101fb366004610a2a565b61055c565b34801561020c57600080fd5b5061011a61021b366004610a4c565b6106a4565b61011a61077c565b6040517fa05a091a0000000000000000000000000000000000000000000000000000000081526004810184905260248101839052604481018290523060648201523360848201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063a05a091a9060a4016020604051808303816000875af11580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190610a65565b905061030281336108bb565b9392505050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d0e30db0346040518263ffffffff1660e01b81526004016000604051808303818588803b15801561037357600080fd5b505af1158015610387573d6000803e3d6000fd5b50506040517f3c6f317f00000000000000000000000000000000000000000000000000000000815260048101879052602481018690523460448201523360648201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169350633c6f317f925060840190506020604051808303816000875af115801561042d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104519190610a65565b90508034111561046e5761046e6104688234610a7e565b336108bb565b92915050565b6040517f1a5b9e62000000000000000000000000000000000000000000000000000000008152600481018490526024810183905260448101829052306064820152336084820181905260009184919073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690631a5b9e629060a4016020604051808303816000875af1158015610523573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105479190610a65565b925061055382826108bb565b50509392505050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d0e30db0346040518263ffffffff1660e01b81526004016000604051808303818588803b1580156105c657600080fd5b505af11580156105da573d6000803e3d6000fd5b50506040517f34f7d1f200000000000000000000000000000000000000000000000000000000815260048101879052346024820152604481018690523360648201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1693506334f7d1f2925060840190506020604051808303816000875af1158015610680573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103029190610a65565b6040517fb460af9400000000000000000000000000000000000000000000000000000000815260048101829052306024820152336044820181905260009183919073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063b460af94906064016020604051808303816000875af1158015610745573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107699190610a65565b925061077582826108bb565b5050919050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d0e30db0346040518263ffffffff1660e01b81526004016000604051808303818588803b1580156107e657600080fd5b505af11580156107fa573d6000803e3d6000fd5b50506040517f6e553f650000000000000000000000000000000000000000000000000000000081523460048201523360248201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169350636e553f65925060440190506020604051808303816000875af1158015610892573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108b69190610a65565b905090565b6040517f2e1a7d4d000000000000000000000000000000000000000000000000000000008152600481018390527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690632e1a7d4d90602401600060405180830381600087803b15801561094357600080fd5b505af1158015610957573d6000803e3d6000fd5b5061097c9250505073ffffffffffffffffffffffffffffffffffffffff821683610980565b5050565b600080600080600085875af19050806109f9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f4554485f5452414e534645525f4641494c454400000000000000000000000000604482015260640160405180910390fd5b505050565b600080600060608486031215610a1357600080fd5b505081359360208301359350604090920135919050565b60008060408385031215610a3d57600080fd5b50508035926020909101359150565b600060208284031215610a5e57600080fd5b5035919050565b600060208284031215610a7757600080fd5b5051919050565b600082821015610ab7577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b50039056fea2646970667358221220af91691c1158d0b89b1e958416ce1d4e6e1b8ab3ae6aa6b2cf825dc77070d2e364736f6c634300080d0033",
  "deployedBytecode": "0x60806040526004361061007f5760003560e01c80639b283ed31161004e5780639b283ed3146101cd578063e46a66c0146101ed578063f14210a614610200578063f6326fb31461022057600080fd5b806321ce312e146100fa5780633fc8cef31461012d57806368c53694146101865780636bf1ad7a1461019957600080fd5b366100f5573373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146100f3576040517f61e790f900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b005b600080fd5b34801561010657600080fd5b5061011a6101153660046109fe565b610228565b6040519081526020015b60405180910390f35b34801561013957600080fd5b506101617f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610124565b61011a610194366004610a2a565b610309565b3480156101a557600080fd5b506101617f000000000000000000000000000000000000000000000000000000000000000081565b3480156101d957600080fd5b5061011a6101e83660046109fe565b610474565b61011a6101fb366004610a2a565b61055c565b34801561020c57600080fd5b5061011a61021b366004610a4c565b6106a4565b61011a61077c565b6040517fa05a091a0000000000000000000000000000000000000000000000000000000081526004810184905260248101839052604481018290523060648201523360848201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063a05a091a9060a4016020604051808303816000875af11580156102d2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f69190610a65565b905061030281336108bb565b9392505050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d0e30db0346040518263ffffffff1660e01b81526004016000604051808303818588803b15801561037357600080fd5b505af1158015610387573d6000803e3d6000fd5b50506040517f3c6f317f00000000000000000000000000000000000000000000000000000000815260048101879052602481018690523460448201523360648201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169350633c6f317f925060840190506020604051808303816000875af115801561042d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104519190610a65565b90508034111561046e5761046e6104688234610a7e565b336108bb565b92915050565b6040517f1a5b9e62000000000000000000000000000000000000000000000000000000008152600481018490526024810183905260448101829052306064820152336084820181905260009184919073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690631a5b9e629060a4016020604051808303816000875af1158015610523573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105479190610a65565b925061055382826108bb565b50509392505050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d0e30db0346040518263ffffffff1660e01b81526004016000604051808303818588803b1580156105c657600080fd5b505af11580156105da573d6000803e3d6000fd5b50506040517f34f7d1f200000000000000000000000000000000000000000000000000000000815260048101879052346024820152604481018690523360648201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1693506334f7d1f2925060840190506020604051808303816000875af1158015610680573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103029190610a65565b6040517fb460af9400000000000000000000000000000000000000000000000000000000815260048101829052306024820152336044820181905260009183919073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063b460af94906064016020604051808303816000875af1158015610745573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107699190610a65565b925061077582826108bb565b5050919050565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d0e30db0346040518263ffffffff1660e01b81526004016000604051808303818588803b1580156107e657600080fd5b505af11580156107fa573d6000803e3d6000fd5b50506040517f6e553f650000000000000000000000000000000000000000000000000000000081523460048201523360248201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169350636e553f65925060440190506020604051808303816000875af1158015610892573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108b69190610a65565b905090565b6040517f2e1a7d4d000000000000000000000000000000000000000000000000000000008152600481018390527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690632e1a7d4d90602401600060405180830381600087803b15801561094357600080fd5b505af1158015610957573d6000803e3d6000fd5b5061097c9250505073ffffffffffffffffffffffffffffffffffffffff821683610980565b5050565b600080600080600085875af19050806109f9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f4554485f5452414e534645525f4641494c454400000000000000000000000000604482015260640160405180910390fd5b505050565b600080600060608486031215610a1357600080fd5b505081359360208301359350604090920135919050565b60008060408385031215610a3d57600080fd5b50508035926020909101359150565b600060208284031215610a5e57600080fd5b5035919050565b600060208284031215610a7757600080fd5b5051919050565b600082821015610ab7577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b50039056fea2646970667358221220af91691c1158d0b89b1e958416ce1d4e6e1b8ab3ae6aa6b2cf825dc77070d2e364736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}